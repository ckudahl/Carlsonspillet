<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Level Devil</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #0a0a0a;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        canvas {
            border: 2px solid #333;
            border-radius: 4px;
        }
        #levelIndicator {
            color: #666;
            font-size: 14px;
            letter-spacing: 2px;
        }
        #deathCounter {
            color: #444;
            font-size: 12px;
        }

        /* Mobile Controls */
        #mobileControls {
            display: none;
            width: 100%;
            max-width: 800px;
            padding: 10px;
            gap: 20px;
            justify-content: space-between;
            align-items: center;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(78, 205, 196, 0.3);
            border: 2px solid #4ecdc4;
            color: #4ecdc4;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .control-btn:active, .control-btn.pressed {
            background: rgba(78, 205, 196, 0.6);
            transform: scale(0.95);
        }

        .jump-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        #jumpBtn, #downBtn {
            width: 70px;
            height: 70px;
            font-size: 28px;
        }

        /* Show mobile controls on touch devices */
        @media (pointer: coarse), (max-width: 900px) {
            #mobileControls {
                display: flex;
            }
            canvas {
                max-width: 100%;
                height: auto;
            }
            #gameContainer {
                width: 100%;
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="levelIndicator">LEVEL 1</div>
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <div id="deathCounter">Deaths: 0</div>
        <div id="mobileControls">
            <div class="control-group">
                <button class="control-btn" id="leftBtn">&#9664;</button>
                <button class="control-btn" id="rightBtn">&#9654;</button>
            </div>
            <button class="control-btn" id="skipLevelBtn">SKIP</button>
            <div class="jump-group">
                <button class="control-btn" id="jumpBtn">&#9650;</button>
                <button class="control-btn" id="downBtn">&#9660;</button>
            </div>
        </div>
    </div>

    <script>
        // ===========================================
        // GAME CONFIGURATION
        // ===========================================
        const CONFIG = {
            // Player physics
            GRAVITY: 0.6,
            JUMP_FORCE: -12,
            MOVE_SPEED: 5,
            MAX_FALL_SPEED: 15,

            // Player appearance
            PLAYER_WIDTH: 30,
            PLAYER_HEIGHT: 40,
            PLAYER_COLOR: '#4ecdc4',
            EYE_COLOR: '#1a1a1a',

            // World
            GROUND_COLOR: '#e8e8e8',
            DOOR_COLOR: '#50c878',
            TRAP_COLOR: '#ff6b6b',
            BACKGROUND_COLOR: '#1a1a1a',

            // Animation
            SQUASH_RECOVERY: 0.15,  // How fast player returns to normal shape
            LANDING_SQUASH: 0.7,    // How much player squashes on landing
            JUMP_STRETCH: 1.3,      // How much player stretches when jumping

            // Death
            DEATH_DELAY: 800,       // Milliseconds to wait before respawn
            CRUSHED_SCALE_Y: 0.15,  // How flat the player gets when crushed
            CRUSHED_SCALE_X: 2.0    // How wide the player gets when crushed
        };

        // ===========================================
        // LEVEL DATA STRUCTURE
        // Each level contains:
        // - platforms: array of {x, y, width, height}
        // - door: {x, y, width, height}
        // - playerStart: {x, y}
        // - traps: array of trap objects (type-specific properties)
        // - triggers: array of {x, type, ...params} - invisible triggers
        // ===========================================
        const LEVELS = [
            // LEVEL 1: "The False Promise"
            // Looks completely safe - flat ground, door on the right
            // TRAP: A block falls extremely fast when player crosses trigger point
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Falling block trap - starts invisible and inactive
                    {
                        id: 'fallingBlock1',
                        type: 'fallingBlock',
                        x: 350,
                        y: -60,           // Starts above screen
                        width: 200,
                        height: 60,
                        speed: 35,        // Extremely fast - almost impossible to react
                        active: false,    // Activated by trigger
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 340      // Where it stops (ground level - height)
                    }
                ],
                triggers: [
                    // When player crosses x=300, activate the falling block
                    {
                        x: 300,
                        action: 'activateTrap',
                        trapId: 'fallingBlock1',
                        triggered: false
                    }
                ]
            },

            // LEVEL 2: "The Collapsing Bridge"
            // A gap with a bridge - looks like a simple jump challenge
            // TRAP: The bridge collapses shortly after you land on it
            {
                platforms: [
                    { x: 0, y: 400, width: 200, height: 50 },    // Left ground
                    { x: 600, y: 400, width: 200, height: 50 }   // Right ground (with door)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // The bridge - looks safe but collapses when you land on it
                    {
                        id: 'bridge1',
                        type: 'collapsingPlatform',
                        x: 275,
                        y: 400,
                        width: 250,
                        height: 20,
                        delay: 400,        // Milliseconds before it falls (just enough to feel safe)
                        fallSpeed: 8,
                        activated: false,
                        shaking: false,
                        falling: false,
                        fallen: false
                    }
                ],
                triggers: []  // No triggers needed - activates on contact
            },

            // LEVEL 3: "The Gauntlet"
            // Flat ground like level 1, but now THREE falling blocks in sequence
            // Tests if player can apply level 1's lesson repeatedly
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Block 1 - first obstacle
                    {
                        id: 'fallingBlock1',
                        type: 'fallingBlock',
                        x: 180,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350
                    },
                    // Block 2 - second obstacle
                    {
                        id: 'fallingBlock2',
                        type: 'fallingBlock',
                        x: 380,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350
                    },
                    // Block 3 - third obstacle
                    {
                        id: 'fallingBlock3',
                        type: 'fallingBlock',
                        x: 560,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350
                    }
                ],
                triggers: [
                    // Trigger for block 1
                    {
                        x: 150,
                        action: 'activateTrap',
                        trapId: 'fallingBlock1',
                        triggered: false
                    },
                    // Trigger for block 2
                    {
                        x: 350,
                        action: 'activateTrap',
                        trapId: 'fallingBlock2',
                        triggered: false
                    },
                    // Trigger for block 3
                    {
                        x: 530,
                        action: 'activateTrap',
                        trapId: 'fallingBlock3',
                        triggered: false
                    }
                ]
            },

            // LEVEL 4: "The Vanishing Act"
            // Large gap with a helpful-looking platform in the middle
            // TRAP: The platform vanishes when you jump in the gap area
            // Solution: Ignore the platform, make one big jump across the whole gap
            {
                platforms: [
                    { x: 0, y: 400, width: 180, height: 50 },    // Left ground
                    { x: 530, y: 400, width: 270, height: 50 }   // Right ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // The vanishing platform - looks helpful but betrays you
                    {
                        id: 'vanishPlatform1',
                        type: 'vanishingPlatform',
                        x: 305,
                        y: 385,
                        width: 100,
                        height: 15,
                        triggerZoneStart: 180,   // Left edge of gap
                        triggerZoneEnd: 530,     // Right edge of gap
                        vanishDuration: 1000,    // Stay vanished for 1 second
                        vanished: false,
                        reappearTimer: 0,
                        disarmed: false          // Once triggered and reappeared, stays solid
                    }
                ],
                triggers: []
            },

            // LEVEL 5: "The Bait and Switch"
            // Door sits on a platform over a gap - when you jump for it,
            // the door flies to the start and the platform vanishes
            // Solution: Jump to trigger it, reverse mid-air, land back at start
            {
                platforms: [
                    { x: 0, y: 400, width: 500, height: 50 }     // Left ground (start) - gap is on the right
                ],
                door: { x: 710, y: 325, width: 40, height: 60 }, // Door on platform over the gap
                playerStart: { x: 50, y: 350 },
                traps: [
                    {
                        id: 'flyingDoor1',
                        type: 'flyingDoor',
                        // Platform under the door
                        platformX: 690,
                        platformY: 385,
                        platformWidth: 100,
                        platformHeight: 15,
                        // Trigger zone (the gap area on the right)
                        triggerZoneStart: 500,
                        triggerZoneEnd: 800,
                        // Where the door should fly to
                        doorTargetX: 80,
                        doorTargetY: 340,
                        // Timing
                        platformVanishDelay: 350,  // Disappears just before player would land
                        platformDelay: 0,
                        // State
                        triggered: false,
                        platformGone: false
                    }
                ],
                triggers: []
            },
            // Add more levels here following the same structure

            // LEVEL 6: "The Patience Test"
            // Flat empty level - looks trivial. A spike wall suddenly appears when you approach.
            // The wall looks jumpable but has spikes on top that kill you.
            // Solution: Wait 7 seconds and the wall disappears.
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    {
                        id: 'spikeWall1',
                        type: 'spikeWall',
                        x: 380,
                        y: 400,               // Starts at ground level (hidden)
                        width: 40,
                        height: 85,           // Looks jumpable but spikes add extra deadly height
                        spikeHeight: 20,      // Spikes on top
                        riseSpeed: 25,        // How fast wall rises
                        targetY: 315,         // Final position (ground - height)
                        disappearDelay: 4000, // 4 seconds before it disappears
                        active: false,
                        rising: false,
                        risen: false,
                        disappearing: false,
                        gone: false,
                        timer: 0
                    }
                ],
                triggers: [
                    {
                        x: 280,
                        action: 'activateTrap',
                        trapId: 'spikeWall1',
                        triggered: false
                    }
                ]
            },

            // LEVEL 7: "The Shrinking Solution"
            // If you jump, the floor disappears and you die.
            // A floating block blocks the path - you can't jump over or past it.
            // Solution: Walk back to start, step on button to shrink, walk under the block.
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 },  // Ground
                    { x: 350, y: 345, width: 60, height: 25 }  // Floating block obstacle (gap underneath for shrunken player)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Jump detector - if player jumps, floor vanishes
                    {
                        id: 'jumpDetector1',
                        type: 'jumpDetector',
                        floorPlatformIndex: 0,  // Index of ground platform to remove
                        triggered: false
                    },
                    // Shrink button - appears when player reaches the block area
                    {
                        id: 'shrinkButton1',
                        type: 'shrinkButton',
                        x: 70,
                        y: 385,
                        width: 50,
                        height: 15,
                        visible: false,
                        activated: false,
                        shrinkScale: 0.4,        // How small the player becomes
                        shrinkDuration: 500      // Animation duration in ms
                    }
                ],
                triggers: [
                    // When player reaches the block, make the button appear at start after delay
                    {
                        x: 340,
                        action: 'showShrinkButton',
                        trapId: 'shrinkButton1',
                        triggered: false,
                        delay: 750,        // 0.75 second delay
                        delayTimer: 0,
                        delayStarted: false
                    }
                ]
            },

            // LEVEL 8: "Unlearn Everything"
            // Looks like level 3 - flat ground with falling blocks
            // TRAP: First two blocks are tall with side spikes - once landed, they block the path!
            // The careful approach from level 3 will get you stuck.
            // Solution: Sprint through! Don't stop to assess like level 3 taught you.
            // EXCEPT: Third block is exactly like level 3 - here you DO need to be careful!
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Block 1 - tall with spikes on sides and top, will block path if you're careful
                    {
                        id: 'fallingBlock1',
                        type: 'fallingBlock',
                        x: 150,
                        y: -150,
                        width: 40,
                        height: 140,
                        speed: 14,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 260,
                        hasSideSpikes: true,
                        hasTopSpikes: true
                    },
                    // Block 2 - tall with spikes on sides and top, will block path if you're careful
                    {
                        id: 'fallingBlock2',
                        type: 'fallingBlock',
                        x: 340,
                        y: -150,
                        width: 40,
                        height: 140,
                        speed: 14,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 260,
                        hasSideSpikes: true,
                        hasTopSpikes: true
                    },
                    // Block 3 - normal like level 3, NOW you need to be careful!
                    {
                        id: 'fallingBlock3',
                        type: 'fallingBlock',
                        x: 560,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350,
                        hasSideSpikes: false
                    }
                ],
                triggers: [
                    // Trigger for block 1 - placed so sprinting passes, careful gets blocked
                    {
                        x: 120,
                        action: 'activateTrap',
                        trapId: 'fallingBlock1',
                        triggered: false
                    },
                    // Trigger for block 2
                    {
                        x: 310,
                        action: 'activateTrap',
                        trapId: 'fallingBlock2',
                        triggered: false
                    },
                    // Trigger for block 3 - same timing as level 3
                    {
                        x: 530,
                        action: 'activateTrap',
                        trapId: 'fallingBlock3',
                        triggered: false
                    }
                ]
            },

            // LEVEL 9: "Catch Me If You Can"
            // Simple flat level, but the door runs away when you approach!
            // It gets tired after several escapes and eventually you can catch it.
            // Gap in the middle adds danger while chasing the door.
            {
                platforms: [
                    { x: 0, y: 400, width: 330, height: 50 },   // Left ground
                    { x: 470, y: 400, width: 330, height: 50 }  // Right ground
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    {
                        id: 'escapingDoor1',
                        type: 'escapingDoor',
                        triggerDistance: 130,     // How close player needs to be to trigger escape
                        escapeCount: 0,           // Tracks how many times door has escaped
                        maxEscapes: 6,            // After this many escapes, door gets exhausted
                        exhausted: false,
                        // Predefined escape points the door can jump to
                        escapePoints: [
                            // Ground level positions (reachable)
                            { x: 50, y: 340 },    // Far left
                            { x: 720, y: 340 },   // Far right
                            { x: 380, y: 340 },   // Center
                            { x: 450, y: 340 },   // Center-right
                            { x: 300, y: 340 },   // Center-left
                            { x: 180, y: 340 },   // Left quarter
                            { x: 600, y: 340 },   // Right quarter
                            { x: 520, y: 340 },   // Mid-right
                            { x: 250, y: 340 },   // Mid-left
                            // Elevated tease positions (will timeout and come down)
                            { x: 380, y: 120 },   // High center
                            { x: 150, y: 180 },   // High left
                            { x: 650, y: 180 }    // High right
                        ]
                    }
                ],
                triggers: []
            },

            // LEVEL 10: "Mirror Mirror"
            // Looks simple: gap, spikes to jump, gap. But controls are REVERSED!
            // Left/Right swapped, Jump is DOWN instead of UP.
            // Wall spikes on the left catch players who instinctively press right (goes left).
            {
                platforms: [
                    { x: 0, y: 400, width: 150, height: 50 },    // Left platform (with wall spikes)
                    { x: 230, y: 400, width: 340, height: 50 },  // Middle platform (with floor spikes)
                    { x: 650, y: 400, width: 150, height: 50 }   // Right platform (with door)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 100, y: 350 },  // Start near the wall spikes
                swapLeftRight: true,   // Left and Right controls are swapped!
                jumpWithDown: true,    // Jump with Down/S instead of Up/W/Space!
                traps: [
                    // Wall spikes on the left - tall enough to kill even when jumping
                    {
                        id: 'wallSpikes1',
                        type: 'wallSpikes',
                        x: 0,
                        y: 200,        // Goes high up
                        width: 25,     // Spike length pointing right
                        height: 200    // Tall enough to catch jumpers
                    },
                    // Floor spikes on middle platform - 3 sets to jump over
                    {
                        id: 'floorSpikes1',
                        type: 'floorSpikes',
                        x: 280,
                        y: 375,
                        width: 40,
                        height: 25
                    },
                    {
                        id: 'floorSpikes2',
                        type: 'floorSpikes',
                        x: 380,
                        y: 375,
                        width: 40,
                        height: 25
                    },
                    {
                        id: 'floorSpikes3',
                        type: 'floorSpikes',
                        x: 480,
                        y: 375,
                        width: 40,
                        height: 25
                    }
                ],
                triggers: []
            },

            // LEVEL 11: "The Launch Trap"
            // Like level 3 with fast falling blocks you can't run under.
            // Blocks 1 & 2: Landing on them launches you into ceiling spikes - must jump OVER.
            // Block 3: Jumping over triggers ground spikes - must land ON it and jump to door.
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground
                ],
                door: { x: 730, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Block 1 - launches into ceiling if landed on
                    {
                        id: 'launchBlock1',
                        type: 'launchBlock',
                        x: 160,
                        y: -60,
                        width: 80,
                        height: 50,
                        speed: 35,
                        active: false,
                        falling: false,
                        landed: false,
                        landedY: 350,
                        launching: false,
                        launched: false,
                        launchSpeed: 25,
                        launchTargetY: 0,
                        ceilingSpikeId: 'ceilingSpikes1'
                    },
                    // Ceiling spikes for block 1
                    {
                        id: 'ceilingSpikes1',
                        type: 'ceilingSpikes',
                        x: 140,
                        y: 0,
                        width: 120,
                        height: 30,
                        visible: false
                    },
                    // Block 2 - launches into ceiling if landed on
                    {
                        id: 'launchBlock2',
                        type: 'launchBlock',
                        x: 340,
                        y: -60,
                        width: 80,
                        height: 50,
                        speed: 35,
                        active: false,
                        falling: false,
                        landed: false,
                        landedY: 350,
                        launching: false,
                        launched: false,
                        launchSpeed: 25,
                        launchTargetY: 0,
                        ceilingSpikeId: 'ceilingSpikes2'
                    },
                    // Ceiling spikes for block 2
                    {
                        id: 'ceilingSpikes2',
                        type: 'ceilingSpikes',
                        x: 320,
                        y: 0,
                        width: 120,
                        height: 30,
                        visible: false
                    },
                    // Block 3 - safe to land on, but jumping over triggers ground spikes
                    {
                        id: 'launchBlock3',
                        type: 'launchBlock',
                        x: 520,
                        y: -60,
                        width: 80,
                        height: 50,
                        speed: 35,
                        active: false,
                        falling: false,
                        landed: false,
                        landedY: 350,
                        launching: false,
                        launched: false,
                        launchSpeed: 0,      // Doesn't launch - safe to land on!
                        launchTargetY: 350,
                        ceilingSpikeId: null
                    },
                    // Popup spikes that appear if trying to jump over block 3
                    {
                        id: 'popupSpikes1',
                        type: 'popupSpikes',
                        x: 610,
                        y: 370,
                        width: 100,
                        height: 30,
                        triggerZoneStart: 600,  // Only after passing block 3 (block ends at 520+80=600)
                        triggerZoneEnd: 720,    // To before door
                        triggered: false,
                        visible: false
                    }
                ],
                triggers: [
                    {
                        x: 130,
                        action: 'activateTrap',
                        trapId: 'launchBlock1',
                        triggered: false
                    },
                    {
                        x: 310,
                        action: 'activateTrap',
                        trapId: 'launchBlock2',
                        triggered: false
                    },
                    {
                        x: 490,
                        action: 'activateTrap',
                        trapId: 'launchBlock3',
                        triggered: false
                    }
                ]
            },

            // LEVEL 12: "Remote Control"
            // Door is on a high platform. Staircase of platforms to reach it.
            // Jump 1: Floor disappears. Jump 2: Platform 1 disappears. Jump 3: Platform 2 AND door platform disappear.
            // Solution: Walk right to reveal button, touch it to control the door, move door to player.
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 },      // Floor (index 0) - extends full width
                    { x: 150, y: 320, width: 100, height: 20 },   // Platform 1 - step 1 (index 1)
                    { x: 280, y: 240, width: 100, height: 20 },   // Platform 2 - step 2 (index 2)
                    { x: 420, y: 160, width: 100, height: 20 }    // Door platform (index 3)
                ],
                door: { x: 440, y: 100, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Jump count tracker for floor
                    {
                        id: 'jumpPlatform0',
                        type: 'jumpCountPlatform',
                        platformX: 0,
                        platformY: 400,
                        disappearAfterJump: 1,
                        gone: false
                    },
                    // Jump count tracker for platform 1
                    {
                        id: 'jumpPlatform1',
                        type: 'jumpCountPlatform',
                        platformX: 150,
                        platformY: 320,
                        disappearAfterJump: 2,
                        gone: false
                    },
                    // Jump count tracker for platform 2
                    {
                        id: 'jumpPlatform2',
                        type: 'jumpCountPlatform',
                        platformX: 280,
                        platformY: 240,
                        disappearAfterJump: 3,
                        gone: false
                    },
                    // Jump count tracker for door platform - also slides door away!
                    {
                        id: 'jumpPlatform3',
                        type: 'jumpCountPlatform',
                        platformX: 420,
                        platformY: 160,
                        disappearAfterJump: 3,
                        gone: false,
                        slideDoor: true,
                        doorSlideTargetX: 760,
                        doorSlideSpeed: 5  // Same as player movement speed
                    },
                    // Door control button - appears when walking right
                    {
                        id: 'doorControlButton1',
                        type: 'doorControlButton',
                        x: 740,
                        y: 385,
                        width: 50,
                        height: 15,
                        visible: false,
                        activated: false
                    }
                ],
                triggers: [
                    // Trigger to show door control button when walking to the right (last 25% = x=600)
                    // Only works if player hasn't jumped yet
                    {
                        x: 600,
                        action: 'showDoorControlButton',
                        trapId: 'doorControlButton1',
                        triggered: false
                    }
                ]
            },

            // LEVEL 13: "Float to Doom"
            // Ceiling is divided into 5 horizontal sections. Parts 1, 3, 5 have spikes.
            // Special mechanic: when you jump, you float all the way to the ceiling!
            // Box 1 under part 2 forces a jump - safe because part 2 has no spikes.
            // Box 2 under part 4 - if you jump, spikes appear in part 4 ceiling and kill you.
            // Solution: Touch box 2, wait 3 seconds for it to disappear, walk to door.
            {
                floatToCeiling: true,  // Special mechanic for this level
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }   // Full floor
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },  // Door in part 5, on the ground
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Ceiling spikes part 1 (x: 0-160) - always visible
                    {
                        type: 'ceilingSpikes',
                        x: 0,
                        y: 0,
                        width: 160,
                        height: 25,
                        visible: true
                    },
                    // Ceiling spikes part 3 (x: 320-480) - always visible
                    {
                        type: 'ceilingSpikes',
                        x: 320,
                        y: 0,
                        width: 160,
                        height: 25,
                        visible: true
                    },
                    // Ceiling spikes part 5 (x: 640-800) - always visible
                    {
                        type: 'ceilingSpikes',
                        x: 640,
                        y: 0,
                        width: 160,
                        height: 25,
                        visible: true
                    },
                    // Ceiling popup spikes part 4 (x: 480-640) - appear when jumping in this zone
                    {
                        type: 'ceilingPopupSpikes',
                        x: 480,
                        y: 0,
                        width: 160,
                        height: 25,
                        visible: false,
                        activated: false,
                        triggerZoneStart: 480,
                        triggerZoneEnd: 640
                    },
                    // Box 1 - under part 2, forces player to jump (safe jump)
                    {
                        type: 'timedBox',
                        x: 200,
                        y: 360,
                        width: 40,
                        height: 40,
                        gone: false,
                        riseAfterTime: 99999  // Never rises - must jump over
                    },
                    // Box 2 - under part 4, blocks path
                    // If player jumps, they die. Must wait for box to rise up.
                    {
                        type: 'timedBox',
                        x: 520,
                        y: 360,
                        width: 40,
                        height: 40,
                        gone: false,
                        riseAfterTime: 2000,  // 2 seconds before it starts rising
                        riseSpeed: 2          // Speed at which it rises
                    }
                ],
                triggers: []
            },

            // LEVEL 14: "Growing Pains"
            // Each jump makes you 5% bigger (size and jump height scale).
            // 3 gaps to jump over, then door with low ceiling blocking it.
            // After 3 jumps you're too big to fit under the ceiling.
            // Solution: Keep jumping to get huge, reach high platform above start,
            // hit button to reset size and disable growth, then complete normally.
            {
                growOnJump: true,  // Special mechanic for this level
                platforms: [
                    { x: 0, y: 400, width: 100, height: 50 },      // Start platform
                    { x: 160, y: 400, width: 120, height: 50 },   // After gap 1 (wider floor)
                    { x: 340, y: 400, width: 120, height: 50 },   // After gap 2 (wider floor)
                    { x: 520, y: 400, width: 280, height: 50 },   // After gap 3 to end
                    { x: 650, y: 320, width: 20, height: 35 },    // Vertical part going up (bottom at y:355, 45px gap)
                    { x: 650, y: 320, width: 150, height: 20 },   // Horizontal part just above door top, to wall
                    { x: 0, y: 180, width: 150, height: 20 }      // High platform (50% wider)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },  // Door under ceiling
                playerStart: { x: 30, y: 350 },
                traps: [
                    // Size reset button on the high platform (hidden until player lands on it)
                    {
                        id: 'sizeResetButton1',
                        type: 'sizeResetButton',
                        x: 55,
                        y: 165,
                        width: 40,
                        height: 15,
                        visible: false,
                        activated: false
                    },
                    // Ceiling spikes - you die if you grow too big (all the way left)
                    {
                        type: 'ceilingSpikes',
                        x: 0,
                        y: 0,
                        width: 800,
                        height: 25,
                        visible: true
                    }
                ],
                triggers: [
                    // Height + position trigger - only shows button when player lands on the platform
                    {
                        type: 'heightReached',
                        maxY: 180,  // Player's feet must be at platform level
                        minX: 0,    // Must be over the platform horizontally
                        maxX: 150,
                        action: 'showSizeResetButton',
                        trapId: 'sizeResetButton1',
                        triggered: false
                    }
                ]
            },

            // LEVEL 15: "The Chase"
            // A spike wall slowly closes in from the left.
            // You need to run right, but rushing triggers traps.
            // Solution: There's a pit - drop into it and let the wall pass over you.
            {
                platforms: [
                    { x: 0, y: 400, width: 330, height: 50 },      // Left floor (before pit)
                    { x: 330, y: 450, width: 100, height: 50 },    // Pit floor (lower)
                    { x: 430, y: 400, width: 370, height: 50 }     // Right floor (after pit)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                hasChaseWall: true,  // Special mechanic flag
                traps: [
                    // The chasing spike wall
                    {
                        id: 'chaseWall',
                        type: 'chaseWall',
                        x: -50,
                        y: 200,
                        width: 50,
                        height: 200,
                        speed: 2,
                        active: false
                    },
                    // Spikes in the pit - falling in kills you!
                    {
                        type: 'floorSpikes',
                        x: 340,
                        y: 425,
                        width: 80,
                        height: 25
                    },
                    // Popup spikes if you rush too fast (past the pit)
                    {
                        type: 'popupSpikes',
                        x: 500,
                        y: 375,
                        width: 60,
                        height: 25,
                        visible: false,
                        triggered: false,
                        triggerZoneStart: 500,
                        triggerZoneEnd: 580
                    },
                    // More popup spikes
                    {
                        type: 'popupSpikes',
                        x: 620,
                        y: 375,
                        width: 60,
                        height: 25,
                        visible: false,
                        triggered: false,
                        triggerZoneStart: 620,
                        triggerZoneEnd: 700
                    }
                ],
                triggers: [
                    // Start the chase when player moves right
                    {
                        x: 100,
                        action: 'activateTrap',
                        trapId: 'chaseWall',
                        triggered: false
                    }
                ],
                // No safe zone - jump over the pit!
            },

            // LEVEL 16: "Lights Out"
            // The level is dark - only a small area around the player is visible.
            // Hidden spikes and gaps everywhere. Navigate carefully!
            {
                isDark: true,  // Special mechanic flag
                visibilityRadius: 80,
                platforms: [
                    { x: 0, y: 400, width: 200, height: 50 },      // Start platform
                    { x: 280, y: 400, width: 100, height: 50 },    // Platform 2
                    { x: 460, y: 400, width: 100, height: 50 },    // Platform 3
                    { x: 640, y: 400, width: 160, height: 50 }     // End platform
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Hidden floor spikes (2 spikes each)
                    {
                        type: 'floorSpikes',
                        x: 300,
                        y: 375,
                        width: 40,
                        height: 25
                    },
                    // More hidden spikes
                    {
                        type: 'floorSpikes',
                        x: 480,
                        y: 375,
                        width: 40,
                        height: 25
                    }
                ],
                triggers: []
            },

            // LEVEL 17: "Now You See Me"
            // Player is only visible under the streetlamp at the start.
            // Must navigate falling blocks and a pit while invisible.
            {
                playerInvisible: true,  // Special mechanic flag
                platforms: [
                    { x: 0, y: 400, width: 350, height: 50 },    // Left ground (up to pit)
                    { x: 400, y: 400, width: 400, height: 50 }   // Right ground (after pit to door)
                ],
                door: { x: 720, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Streetlamp at the start - provides cone of light
                    {
                        type: 'streetlamp',
                        x: 80,
                        y: 250,  // Lamp head position
                        lightRadius: 70,  // Radius of light cone at ground level
                        lightConeTop: 20  // Radius at top of cone
                    },
                    // Falling block 1 - after leaving the light
                    {
                        id: 'fallingBlock1',
                        type: 'fallingBlock',
                        x: 200,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350
                    },
                    // Falling block 2 - after the pit
                    {
                        id: 'fallingBlock2',
                        type: 'fallingBlock',
                        x: 500,
                        y: -50,
                        width: 60,
                        height: 50,
                        speed: 35,
                        active: false,
                        triggered: false,
                        falling: false,
                        landed: false,
                        landedY: 350
                    }
                ],
                triggers: [
                    // Trigger for falling block 1
                    {
                        x: 170,
                        action: 'activateTrap',
                        trapId: 'fallingBlock1',
                        triggered: false
                    },
                    // Trigger for falling block 2
                    {
                        x: 470,
                        action: 'activateTrap',
                        trapId: 'fallingBlock2',
                        triggered: false
                    }
                ]
            },

            // LEVEL 18: "The Growing Level"
            // Looks simple but the level keeps expanding after each "door"
            // Door 1 melts -> level expands right, climb up to door 2
            // Door 2 melts -> level expands down, descend with spikes, chase wall at bottom
            {
                initialCanvasWidth: 800,
                initialCanvasHeight: 450,
                expansions: {
                    1: { canvasWidth: 1150 },  // Expand right for climbing section
                    2: { canvasWidth: 1150, canvasHeight: 650, newDoor: { x: 1050, y: 530 } }  // Expand down
                },
                platforms: [
                    // SECTION 1 - Initial visible area
                    { x: 0, y: 400, width: 180, height: 50 },           // Left ground (before pit)
                    { x: 230, y: 400, width: 570, height: 50 },         // Right ground (after pit)

                    // SECTION 2 - Revealed after door 1 melts (climbing + top jump)
                    { x: 820, y: 360, width: 60, height: 20, revealStage: 1 },   // Climb 1
                    { x: 900, y: 280, width: 55, height: 20, revealStage: 1 },   // Climb 2
                    { x: 820, y: 190, width: 55, height: 20, revealStage: 1 },   // Climb 3
                    { x: 950, y: 110, width: 50, height: 20, revealStage: 1 },   // Climb 4 - jump right to door
                    { x: 1060, y: 95, width: 80, height: 20, revealStage: 1 },   // Door 2 platform

                    // SECTION 3 - Revealed after door 2 melts (descend left, then chase right)
                    // Descending platforms going LEFT - positioned to avoid climbing platforms
                    { x: 920, y: 180, width: 70, height: 20, revealStage: 2 },   // Descend 1
                    { x: 740, y: 270, width: 70, height: 20, revealStage: 2 },   // Descend 2
                    { x: 560, y: 360, width: 70, height: 20, revealStage: 2 },   // Descend 3
                    { x: 380, y: 450, width: 70, height: 20, revealStage: 2 },   // Descend 4
                    { x: 200, y: 520, width: 70, height: 20, revealStage: 2 },   // Descend 5
                    { x: 50, y: 550, width: 100, height: 20, revealStage: 2 },   // Landing platform (left side)
                    // Bottom ground for chase section
                    { x: 0, y: 590, width: 1150, height: 60, revealStage: 2 },   // Full bottom ground
                    // Final platform with real door
                    { x: 1000, y: 590, width: 150, height: 60, revealStage: 2 }  // Door platform (same height, right side)
                ],
                door: { x: -100, y: -100, width: 40, height: 60 },  // Hidden initially
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Floor spikes in section 1
                    { type: 'floorSpikes', x: 400, y: 375, width: 80, height: 25 },

                    // Fake door 1 - melts and triggers expansion 1
                    {
                        type: 'meltingDoor',
                        x: 700,
                        y: 340,
                        width: 40,
                        height: 60,
                        melting: false,
                        melted: false,
                        meltProgress: 0,
                        expansionStage: 1
                    },

                    // Fake door 2 - at top right, beyond initial view (hidden until expansion 1)
                    {
                        type: 'meltingDoor',
                        x: 1070,
                        y: 35,
                        width: 40,
                        height: 60,
                        melting: false,
                        melted: false,
                        meltProgress: 0,
                        expansionStage: 2,
                        revealStage: 1
                    },

                    // Bottom spikes for chase section
                    { type: 'floorSpikes', x: 300, y: 565, width: 50, height: 25, revealStage: 2 },
                    { type: 'floorSpikes', x: 450, y: 565, width: 50, height: 25, revealStage: 2 },
                    { type: 'floorSpikes', x: 620, y: 565, width: 50, height: 25, revealStage: 2 },
                    { type: 'floorSpikes', x: 780, y: 565, width: 50, height: 25, revealStage: 2 },
                    { type: 'floorSpikes', x: 920, y: 565, width: 50, height: 25, revealStage: 2 },

                    // Chase wall - activated when section 3 is revealed, SMASHES THE DOOR!
                    {
                        type: 'chaseWall',
                        x: -50,
                        y: 490,
                        width: 40,
                        height: 100,
                        speed: 14,
                        spikeHeight: 20,
                        active: false,
                        revealStage: 2,
                        smashDoor: true,
                        doorSmashed: false
                    }
                ],
                triggers: []
            },

            // LEVEL 19: "Opposite Day"
            // Doors kill you. Spikes are the goal. But also spikes kill you.
            // The ultimate troll: everything is a lie.
            {
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }  // Ground (will collapse)
                ],
                door: { x: -100, y: -100, width: 40, height: 60 },  // Hidden until spikes transform
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Killer door 1 - at 1/3 position
                    {
                        id: 'killerDoor1',
                        type: 'killerDoor',
                        x: 230,
                        y: 340,
                        width: 40,
                        height: 60
                    },
                    // Killer door 2 - at 2/3 position
                    {
                        id: 'killerDoor2',
                        type: 'killerDoor',
                        x: 490,
                        y: 340,
                        width: 40,
                        height: 60
                    },
                    // Transforming spikes on the right - will become the real door
                    {
                        id: 'transformSpikes',
                        type: 'transformingSpikes',
                        x: 700,
                        y: 375,
                        width: 60,
                        height: 25,
                        transforming: false,
                        transformed: false,
                        transformProgress: 0
                    },
                    // Flying fake door - hidden initially, appears at start
                    {
                        id: 'fakeDoorStart',
                        type: 'flyingFakeDoor',
                        x: 70,
                        y: 340,
                        width: 40,
                        height: 60,
                        visible: false,
                        flying: false,
                        gone: false,
                        flyProgress: 0,
                        collapseFloorIndex: 0  // Collapse the ground when door flies away
                    }
                ],
                triggers: [
                    // When player gets near the spikes, wait 1 second then show fake door at start
                    {
                        type: 'proximity',
                        x: 720,
                        y: 370,
                        proximityX: 60,
                        proximityY: 50,
                        action: 'showTrap',
                        trapId: 'fakeDoorStart',
                        delay: 1000,
                        delayTimer: 0,
                        delayStarted: false,
                        triggered: false
                    },
                    // When player gets near the fake door position (after going back), wait 1 second then transform spikes
                    // Only triggers after fake door is visible (so player has been to the spikes first)
                    {
                        type: 'proximity',
                        x: 120,
                        y: 370,
                        proximityX: 100,
                        proximityY: 60,
                        action: 'startTransformation',
                        trapId: 'transformSpikes',
                        delay: 1000,
                        delayTimer: 0,
                        delayStarted: false,
                        triggered: false,
                        requiresTrapVisible: 'fakeDoorStart'
                    }
                ]
            },

            // LEVEL 20: "Runner"
            // Subway Surfer style! Dodge spikes, collect coins, survive 25 seconds.
            // Completely different gameplay - 3D perspective, lane switching.
            {
                isRunnerLevel: true,
                platforms: [],
                door: { x: -100, y: -100, width: 40, height: 60 },
                playerStart: { x: 400, y: 350 },
                traps: [],
                triggers: []
            },

            // LEVEL 21: "Boss Battle"
            // Fight a boss on a floating platform! Dodge fireballs, jump on head when burrowed.
            // After defeating boss, door appears... but it's a trap! Fall off either side.
            {
                platforms: [
                    // Full platform - holes appear later when trap is triggered
                    { x: 0, y: 400, width: 70, height: 50, id: 'leftEdge' },
                    { x: 70, y: 400, width: 660, height: 50 },
                    { x: 730, y: 400, width: 70, height: 50, id: 'rightEdge' }
                ],
                door: { x: -100, y: -100, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    {
                        type: 'boss',
                        x: 580,
                        y: 200,
                        width: 80,
                        height: 200,
                        health: 3,
                        state: 'standing',
                        fireballTimer: 800,
                        fireballsToShoot: 4,
                        fireballsFired: 0,
                        fireballs: [],
                        burrowProgress: 0,
                        headX: 580,
                        headDirection: -1,
                        headSpeed: 5,
                        deathProgress: 0,
                        defeated: false
                    },
                    {
                        type: 'killerDoor',
                        x: 380,
                        y: 340,
                        width: 40,
                        height: 60,
                        visible: false,
                        bossVictoryDoor: true,
                        simpleKill: false
                    }
                ],
                triggers: [
                    {
                        type: 'pitFall',
                        y: 420,
                        xMin: 0,
                        xMax: 70,
                        requiresTrapTriggered: true,
                        action: 'expandDown'
                    },
                    {
                        type: 'pitFall',
                        y: 420,
                        xMin: 730,
                        xMax: 800,
                        requiresTrapTriggered: true,
                        action: 'expandDown'
                    }
                ],
                expansions: {
                    1: {
                        canvasHeight: 650,
                        newDoor: { x: 380, y: 540 }
                    }
                },
                secretPlatforms: [
                    { x: 0, y: 600, width: 800, height: 50, revealStage: 1 }
                ]
            },

            // LEVEL 22: "The Echo"
            // A dark copy follows your every move with a delay.
            // Backtracking across the bridge means facing your past self.
            {
                initialCanvasWidth: 1000,
                initialCanvasHeight: 550,
                hasShadow: true,
                shadowDelay: 4000,
                platforms: [
                    // Ground - LEFT SIDE ONLY (pit on right)
                    { x: 0, y: 500, width: 350, height: 50 },
                    // Platform A - left stepping stone
                    { x: 50, y: 390, width: 150, height: 15 },
                    // Platform B - right side, over the pit, has button
                    { x: 780, y: 390, width: 170, height: 15 },
                    // Bridge connecting A side to B side
                    { x: 170, y: 280, width: 700, height: 15 },
                    // Platform D - door platform, HIDDEN until button pressed
                    { x: 50, y: 170, width: 170, height: 15, visible: false, id: 'doorPlatform' }
                ],
                door: { x: 110, y: 110, width: 40, height: 60, visible: false },
                playerStart: { x: 60, y: 450 },
                traps: [
                    // Button on Platform B - reveals door platform
                    {
                        type: 'yourFollowerButton',
                        x: 820,
                        y: 365,
                        width: 50,
                        height: 25,
                        pressed: false,
                        revealsId: 'doorPlatform'
                    }
                ],
                triggers: []
            },

            // LEVEL 23: "Role Reversal"
            // You control the spike, not the player.
            {
                controlSpike: true,
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 }
                ],
                door: { x: 700, y: 340, width: 40, height: 60 },
                playerStart: { x: 100, y: 360 },
                traps: [
                    // The enemy - static until killed
                    {
                        type: 'yourEnemy',
                        x: 280,
                        y: 340,
                        width: 50,
                        height: 60,
                        alive: true
                    },
                    // The spike YOU control
                    {
                        type: 'yourSpike',
                        x: 420,
                        y: 370,
                        width: 30,
                        height: 30,
                        vx: 0,
                        vy: 0,
                        onGround: true
                    }
                ],
                triggers: []
            },

            // LEVEL 24: "Portal"
            // Enter the ground door to teleport to the platform. Then go back in to win.
            {
                portalLevel: true,
                platforms: [
                    { x: 0, y: 400, width: 350, height: 50 },    // Left ground
                    { x: 450, y: 400, width: 350, height: 50 },  // Right ground (hole in middle)
                    { x: 300, y: 250, width: 200, height: 20 },  // Floating platform
                    { x: 580, y: 150, width: 120, height: 20 }   // Top right platform
                ],
                door: { x: 700, y: 340, width: 40, height: 60 },  // Ground door (entry)
                playerStart: { x: 50, y: 360 },
                traps: [
                    // Platform door (exit/win)
                    {
                        type: 'portalDoor',
                        x: 300,
                        y: 190,
                        width: 40,
                        height: 60
                    },
                    // Killer door on top right platform
                    {
                        type: 'killerDoor',
                        x: 610,
                        y: 90,
                        width: 40,
                        height: 60,
                        visible: true
                    },
                    // Spike on floating platform
                    {
                        type: 'spikes',
                        x: 390,
                        y: 235,
                        width: 25,
                        height: 15
                    }
                ],
                triggers: []
            },

            // LEVEL 25: "Role Reversal 2 - The Door's Journey"
            // Normal horizontal level - jump across two spike sets to reach door on right.
            // When player reaches door, it flies to left and lands on platform above start.
            // Button appears on far right. Press it to control the door like a player.
            // Door must navigate to player. Jumping past spike2 triggers temporary spikes!
            {
                playableDoorLevel: true,
                platforms: [
                    { x: 0, y: 400, width: 800, height: 50 },      // Ground
                    { x: 20, y: 280, width: 100, height: 20 }       // Platform above start for door to land on
                ],
                door: { x: 650, y: 340, width: 40, height: 60 },
                playerStart: { x: 50, y: 350 },
                traps: [
                    // Spike set 1 - first obstacle for player
                    {
                        id: 'spikes1',
                        type: 'spikes',
                        x: 200,
                        y: 385,
                        width: 60,
                        height: 15
                    },
                    // Spike set 2 - second obstacle for player
                    {
                        id: 'spikes2',
                        type: 'spikes',
                        x: 450,
                        y: 385,
                        width: 60,
                        height: 15
                    },
                    // Hidden spikes to the RIGHT of spike2 - appear when door jumps in zone, disappear after time
                    {
                        id: 'doorTrapSpikes',
                        type: 'doorJumpTriggerSpikes',
                        x: 580,
                        y: 385,
                        width: 80,
                        height: 15,
                        visible: false,
                        triggerZoneX: 520,  // Door must be past this X to trigger
                        disappearDelay: 2000  // Disappear after 2 seconds
                    },
                    // Playable door control button - appears after door flies away
                    {
                        id: 'playableDoorButton',
                        type: 'playableDoorButton',
                        x: 740,
                        y: 385,
                        width: 50,
                        height: 15,
                        visible: false,
                        activated: false
                    }
                ],
                triggers: [
                    // When player reaches door area, door flies away
                    {
                        x: 610,
                        action: 'doorFlyAway',
                        targetX: 40,
                        targetY: 220,
                        triggered: false
                    }
                ]
            },

        ];

        // ===========================================
        // GAME STATE
        // ===========================================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let currentLevel = 0;
        let deaths = 0;
        let levelComplete = false;
        let transitioning = false;

        // Player state
        let player = {
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            width: CONFIG.PLAYER_WIDTH,
            height: CONFIG.PLAYER_HEIGHT,
            onGround: false,
            facingRight: true,
            // Animation states
            scaleX: 1,       // For squash/stretch
            scaleY: 1,
            wasInAir: false, // Track if we just landed
            // Death states
            dead: false,
            deathType: null,  // 'crushed', 'fallen', etc.
            deathTimer: 0,
            // Shrink states
            shrinking: false,
            shrinkTarget: 1,
            shrinkSpeed: 0,
            // Growth states (for grow-on-jump levels)
            sizeScale: 1,
            growthDisabled: false,
            // Gravity flip state
            gravityFlipped: false,
            // Invisibility state
            invisible: false,
            invisibleAnim: 0  // Animation progress (0 = visible, 1 = invisible)
        };

        // Input state
        const keys = {
            left: false,
            right: false,
            up: false,
            down: false
        };

        // Current level data (reset each level)
        let platforms = [];
        let door = {};
        let traps = [];
        let triggers = [];

        // Door animation state
        let doorAnim = {
            active: false,
            startX: 0,
            startY: 0,
            targetX: 0,
            targetY: 0,
            progress: 0,        // 0 to 1
            duration: 1200      // ms for full animation
        };

        // Door control state (for levels where player controls the door)
        let doorControl = {
            active: false,
            speed: 4
        };

        // Playable door state (door that moves like a player with physics)
        let playableDoor = {
            active: false,
            vx: 0,
            vy: 0,
            onGround: false,
            scaleX: 1,
            scaleY: 1,
            wasInAir: false,
            dead: false,
            deathTimer: 0,
            facingRight: true,
            jumpedDown: false  // Track if door has jumped down from platform
        };

        // Simple linear door slide (moves straight at constant speed)
        let doorSlide = {
            active: false,
            targetX: 0,
            speed: 5  // Same as player move speed
        };

        // Jump counter for levels that track jumps
        let jumpCount = 0;

        // Runner level state (Subway Surfer style)
        let runner = {
            active: false,
            lane: 1,              // 0 = left, 1 = center, 2 = right
            targetLane: 1,        // For smooth lane switching
            laneX: 400,           // Current X position
            timer: 0,             // Time survived in ms
            goalTime: 25000,      // 25 seconds to reach goal
            obstacles: [],        // {lane, z, type: 'spike'/'box'}
            coins: [],            // {lane, z}
            coinsCollected: 0,
            fallingBoxes: [],     // {lane, y, vy}
            speed: 8,             // How fast obstacles approach
            doorApproaching: false,
            doorZ: 1000,
            // Death animation state
            deathAnim: 0,         // Animation progress (0-1)
            deathType: null,      // 'spike' or 'box'
            deathVY: 0,           // Vertical velocity during death
            deathVX: 0,           // Horizontal velocity during death
            deathRotation: 0     // Rotation during death tumble
        };

        // Level expansion state (for levels with melting doors)
        let levelExpansion = {
            stage: 0,           // Current expansion stage (0 = initial)
            expanding: false,   // Currently animating expansion
            expandProgress: 0,  // Animation progress 0-1
            targetWidth: 800,   // Target canvas width
            targetHeight: 450   // Target canvas height
        };

        // Shadow state (for copycat level)
        let shadow = {
            active: false,
            history: [],        // Array of {x, y, time} positions
            x: 0,
            y: 0,
            delay: 1500         // How far behind shadow is (ms)
        };

        // Fake timer state
        let fakeTimer = {
            active: false,
            timeLeft: 5000,
            revealed: false,    // True when player waited and timer is shown as fake
            playerMovedTime: 0  // Track when player last moved
        };

        // Spike control state (for "Role Reversal" level)
        let spikeControl = {
            active: false,
            playerAutoWalk: false,
            enemyDead: false,
            doorDead: false,
            doorDeathAnim: 0,
            doorFragments: []
        };

        // Portal level state
        let portalState = {
            active: false,
            teleported: false,
            teleporting: false,
            teleportAnim: 0,
            exitedPortalDoor: false,  // Must exit before re-entering to win
            enteringDoor: null  // Which door player is entering
        };

        // Rising lava state
        let risingLava = {
            active: false,
            x: 0,               // For horizontal lava
            y: 450,             // For vertical lava
            speed: 3,
            direction: 'horizontal'  // 'horizontal' or 'vertical'
        };

        // Dramatic countdown state
        let dramaticCountdown = {
            active: false,
            count: 10,
            timer: 0,
            explosions: []      // Visual explosion effects
        };

        // Flashing platforms state
        let flashingPlatforms = {
            active: false,
            timer: 0,
            visible: true       // Whether flashing platforms are currently visible
        };

        // Mimic door state
        let mimicDoor = {
            active: false,
            lastPlayerX: 0,
            stunTimer: 0        // Brief stun when player reverses
        };

        // Loop level state
        let levelLoop = {
            loopCount: 0,       // How many times level has looped
            triggered: false
        };

        // ===========================================
        // LEVEL MANAGEMENT
        // ===========================================

        /**
         * Load a level by index
         * Deep clones the level data so we can modify traps/triggers without affecting the original
         */
        function loadLevel(levelIndex) {
            const level = LEVELS[levelIndex];

            // Deep clone level data
            platforms = JSON.parse(JSON.stringify(level.platforms));
            door = JSON.parse(JSON.stringify(level.door));
            traps = JSON.parse(JSON.stringify(level.traps));
            triggers = JSON.parse(JSON.stringify(level.triggers));

            // Set initial visibility for platforms with revealStage
            for (const plat of platforms) {
                if (plat.revealStage !== undefined && plat.revealStage > 0) {
                    plat.visible = false;
                } else if (plat.visible === undefined) {
                    plat.visible = true;  // Default to visible if not explicitly set
                }
                // Otherwise preserve the explicit visible value from level definition
            }

            // Set initial visibility for traps with revealStage
            for (const trap of traps) {
                if (trap.revealStage !== undefined && trap.revealStage > 0) {
                    trap.visible = false;
                } else if (trap.visible === undefined) {
                    trap.visible = true;  // Default to visible if not explicitly set
                }
                // Otherwise preserve the explicit visible value from level definition
            }

            // Reset player position and state
            player.x = level.playerStart.x;
            player.y = level.playerStart.y;
            player.vx = 0;
            player.vy = 0;
            player.onGround = false;
            player.scaleX = 1;
            player.scaleY = 1;
            player.facingRight = true;
            player.dead = false;
            player.deathType = null;
            player.deathTimer = 0;

            // Reset player size (in case they were shrunk or grown)
            player.width = CONFIG.PLAYER_WIDTH;
            player.height = CONFIG.PLAYER_HEIGHT;
            player.shrinking = false;
            player.shrinkTarget = 1;
            player.shrinkSpeed = 0;
            player.sizeScale = 1;
            player.growthDisabled = false;
            player.gravityFlipped = false;

            // Reset invisibility state (will be updated based on light position)
            player.invisible = false;
            player.invisibleAnim = 0;

            levelComplete = false;
            transitioning = false;

            // Reset door animation
            doorAnim.active = false;
            doorAnim.progress = 0;

            // Reset door control, door slide, and jump count
            doorControl.active = false;
            doorSlide.active = false;
            jumpCount = 0;

            // Reset playable door state
            playableDoor.active = false;
            playableDoor.vx = 0;
            playableDoor.vy = 0;
            playableDoor.onGround = false;
            playableDoor.scaleX = 1;
            playableDoor.scaleY = 1;
            playableDoor.wasInAir = false;
            playableDoor.dead = false;
            playableDoor.deathTimer = 0;
            playableDoor.facingRight = true;
            playableDoor.jumpedDown = false;

            // Reset runner state
            runner.active = level.isRunnerLevel || false;
            runner.lane = 1;
            runner.targetLane = 1;
            runner.laneX = 400;
            runner.timer = 0;
            runner.obstacles = [];
            runner.coins = [];
            runner.coinsCollected = 0;
            runner.fallingBoxes = [];
            runner.doorApproaching = false;
            runner.doorZ = 1000;
            runner.deathAnim = 0;
            runner.deathType = null;
            runner.deathVY = 0;
            runner.deathVX = 0;

            // Reset shadow state (copycat level)
            shadow.active = level.hasShadow || false;
            shadow.history = [];
            shadow.x = level.playerStart.x;
            shadow.y = level.playerStart.y;
            shadow.delay = level.shadowDelay || 1500;

            // Reset fake timer state
            fakeTimer.active = level.hasFakeTimer || false;
            fakeTimer.timeLeft = level.fakeTimerDuration || 5000;
            fakeTimer.revealed = false;
            fakeTimer.playerMovedTime = Date.now();
            fakeTimer.stillTime = 0;

            // Reset spike control state
            spikeControl.active = level.controlSpike || false;
            spikeControl.playerAutoWalk = false;
            spikeControl.enemyDead = false;
            spikeControl.doorDead = false;
            spikeControl.doorDeathAnim = 0;
            spikeControl.doorFragments = [];

            // Reset portal state
            portalState.active = level.portalLevel || false;
            portalState.teleported = false;
            portalState.teleporting = false;
            portalState.teleportAnim = 0;
            portalState.exitedPortalDoor = false;
            portalState.enteringDoor = null;

            // Reset gravity flip state
            player.gravityFlipped = false;
            runner.deathRotation = 0;

            // Reset level expansion state
            levelExpansion.stage = 0;
            levelExpansion.expanding = false;
            levelExpansion.expandProgress = 0;

            // Set initial canvas size (some levels may start wider/taller)
            const initialWidth = level.initialCanvasWidth || 800;
            const initialHeight = level.initialCanvasHeight || 450;
            canvas.width = initialWidth;
            canvas.height = initialHeight;
            levelExpansion.targetWidth = initialWidth;
            levelExpansion.targetHeight = initialHeight;

            // Update UI
            document.getElementById('levelIndicator').textContent = `LEVEL ${levelIndex + 1}`;
        }

        /**
         * Kill the player with a specific death type
         * This triggers the death animation before restarting
         */
        function killPlayer(deathType) {
            if (player.dead) return;  // Already dead, ignore

            player.dead = true;
            player.deathType = deathType;
            player.vx = 0;
            player.vy = 0;

            // Check if this is a runner level death - longer delay for animation
            const levelData = LEVELS[currentLevel];
            if (levelData && levelData.isRunnerLevel && runner.active) {
                player.deathTimer = 1200;  // 1.2 seconds for runner death animation
                runner.deathAnim = 0;
                runner.deathType = deathType;
                runner.deathVY = -12;  // Pop up initially
                runner.deathVX = (Math.random() - 0.5) * 8;  // Random sideways momentum
                runner.deathRotation = 0;
            } else {
                player.deathTimer = CONFIG.DEATH_DELAY;
            }

            // Apply death visual based on type
            switch(deathType) {
                case 'crushed':
                    // Flatten the player dramatically
                    player.scaleY = CONFIG.CRUSHED_SCALE_Y;
                    player.scaleX = CONFIG.CRUSHED_SCALE_X;
                    break;
                case 'fallen':
                    // Player fell off - no special visual needed
                    break;
            }

            deaths++;
            document.getElementById('deathCounter').textContent = `Deaths: ${deaths}`;
        }

        /**
         * Restart the current level (called after death animation)
         */
        function restartLevel() {
            loadLevel(currentLevel);
        }

        /**
         * Advance to next level
         */
        function nextLevel() {
            currentLevel++;
            if (currentLevel >= LEVELS.length) {
                // Game complete! For now, loop back
                currentLevel = 0;
                deaths = 0;
            }
            loadLevel(currentLevel);
        }

        // ===========================================
        // INPUT HANDLING
        // ===========================================

        document.addEventListener('keydown', (e) => {
            // Runner mode lane switching
            if (LEVELS[currentLevel] && LEVELS[currentLevel].isRunnerLevel && runner.active) {
                if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                    runner.targetLane = Math.max(0, runner.targetLane - 1);
                    e.preventDefault();
                    return;
                }
                if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                    runner.targetLane = Math.min(2, runner.targetLane + 1);
                    e.preventDefault();
                    return;
                }
            }

            switch(e.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    keys.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    keys.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    keys.up = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    keys.down = true;
                    e.preventDefault();
                    break;
                case 'KeyH':
                    // Debug: skip level
                    levelComplete = true;
                    e.preventDefault();
                    break;
                case 'KeyJ':
                    // Debug: skip 5 levels
                    currentLevel += 4;  // +4 because nextLevel() adds 1 more
                    if (currentLevel >= LEVELS.length) {
                        currentLevel = LEVELS.length - 1;
                    }
                    levelComplete = true;
                    e.preventDefault();
                    break;
                case 'KeyK':
                    // Debug: go to last level
                    currentLevel = LEVELS.length - 1;
                    loadLevel(currentLevel);
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    keys.up = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    keys.down = false;
                    break;
            }
        });

        // ===========================================
        // MOBILE TOUCH CONTROLS
        // ===========================================

        const mobileButtons = {
            leftBtn: 'left',
            rightBtn: 'right',
            jumpBtn: 'up',
            downBtn: 'down',
            skipLevelBtn: 'skip' // Add the new skip button here
        };

        // Track which buttons each touch is currently pressing
        const activeTouches = new Map();

        function getButtonAtPoint(x, y) {
            const element = document.elementFromPoint(x, y);
            if (element && mobileButtons[element.id]) {
                return element;
            }
            return null;
        }

        function pressButton(btn) {
            if (!btn) return;

            // Handle special buttons that don't map to `keys` object
            if (btn.id === 'skipLevelBtn') {
                levelComplete = true; // Trigger level transition
                return;
            }

            const keyName = mobileButtons[btn.id];
            if (!keyName) return;

            keys[keyName] = true;
            btn.classList.add('pressed');

            // Handle runner mode lane switching
            if (LEVELS[currentLevel] && LEVELS[currentLevel].isRunnerLevel && runner.active) {
                if (keyName === 'left') {
                    runner.targetLane = Math.max(0, runner.targetLane - 1);
                } else if (keyName === 'right') {
                    runner.targetLane = Math.min(2, runner.targetLane + 1);
                }
            }
        }

        function releaseButton(btn) {
            if (!btn) return;

            // Special buttons don't need 'keys' release
            if (btn.id === 'skipLevelBtn') {
                return;
            }

            const keyName = mobileButtons[btn.id];
            if (!keyName) return;

            // Only release if no other touch is on this button
            let stillPressed = false;
            activeTouches.forEach((activeBtn) => {
                if (activeBtn === btn) stillPressed = true;
            });

            if (!stillPressed) {
                keys[keyName] = false;
                btn.classList.remove('pressed');
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const btn = getButtonAtPoint(touch.clientX, touch.clientY);
                if (btn) {
                    activeTouches.set(touch.identifier, btn);
                    pressButton(btn);
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const oldBtn = activeTouches.get(touch.identifier);
                const newBtn = getButtonAtPoint(touch.clientX, touch.clientY);

                if (oldBtn !== newBtn) {
                    // Finger moved to a different button (or off buttons)
                    if (oldBtn) {
                        activeTouches.delete(touch.identifier);
                        releaseButton(oldBtn);
                    }
                    if (newBtn) {
                        activeTouches.set(touch.identifier, newBtn);
                        pressButton(newBtn);
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (const touch of e.changedTouches) {
                const btn = activeTouches.get(touch.identifier);
                if (btn) {
                    activeTouches.delete(touch.identifier);
                    releaseButton(btn);
                }
            }
        }

        // Global touch listeners for sliding between buttons
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd, { passive: false });
        document.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        // Mouse support for desktop testing
        let mouseDownBtn = null;

        Object.keys(mobileButtons).forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (!btn) return;

            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                mouseDownBtn = btn;
                pressButton(btn);
            });
        });

        document.addEventListener('mouseup', () => {
            if (mouseDownBtn) {
                releaseButton(mouseDownBtn);
                mouseDownBtn = null;
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (mouseDownBtn) {
                const newBtn = getButtonAtPoint(e.clientX, e.clientY);
                if (newBtn !== mouseDownBtn) {
                    releaseButton(mouseDownBtn);
                    mouseDownBtn = newBtn;
                    if (newBtn) pressButton(newBtn);
                }
            }
        });

        // ===========================================
        // COLLISION DETECTION
        // ===========================================

        /**
         * Check if two rectangles overlap
         */
        function rectsCollide(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        /**
         * Check collision with all platforms and return resolved position
         */
        function resolveCollisions() {
            player.onGround = false;

            // Combine platforms with traps that act as solids
            // Filter out hidden platforms
            const solids = platforms.filter(p => p.visible !== false);
            for (const trap of traps) {
                // Landed falling blocks become solid
                if (trap.type === 'fallingBlock' && trap.landed) {
                    solids.push({
                        x: trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
                // Collapsing platforms are solid until they fall away
                if (trap.type === 'collapsingPlatform' && !trap.fallen) {
                    solids.push({
                        x: trap.shaking ? trap.x + (Math.random() - 0.5) * 6 : trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
                // Vanishing platforms are solid only when not vanished
                if (trap.type === 'vanishingPlatform' && !trap.vanished) {
                    solids.push({
                        x: trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
                // Flying door platforms are solid until they vanish
                if (trap.type === 'flyingDoor' && !trap.platformGone) {
                    solids.push({
                        x: trap.platformX,
                        y: trap.platformY,
                        width: trap.platformWidth,
                        height: trap.platformHeight
                    });
                }
                // Spike walls are solid when risen and not gone
                if (trap.type === 'spikeWall' && (trap.rising || trap.risen) && !trap.gone) {
                    solids.push({
                        x: trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
                // Launch blocks are solid when landed and not yet launched
                if (trap.type === 'launchBlock' && trap.landed && !trap.launching && !trap.launched) {
                    solids.push({
                        x: trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
                // Timed boxes are solid until they disappear
                if (trap.type === 'timedBox' && !trap.gone) {
                    solids.push({
                        x: trap.x,
                        y: trap.y,
                        width: trap.width,
                        height: trap.height
                    });
                }
            }

            for (const platform of solids) {
                if (rectsCollide(player, platform)) {
                    // Calculate overlap on each axis
                    const overlapLeft = (player.x + player.width) - platform.x;
                    const overlapRight = (platform.x + platform.width) - player.x;
                    const overlapTop = (player.y + player.height) - platform.y;
                    const overlapBottom = (platform.y + platform.height) - player.y;

                    // Find smallest overlap to determine collision side
                    const minOverlapX = Math.min(overlapLeft, overlapRight);
                    const minOverlapY = Math.min(overlapTop, overlapBottom);

                    if (minOverlapX < minOverlapY) {
                        // Horizontal collision
                        if (overlapLeft < overlapRight) {
                            player.x = platform.x - player.width;
                        } else {
                            player.x = platform.x + platform.width;
                        }
                        player.vx = 0;
                    } else {
                        // Vertical collision
                        if (overlapTop < overlapBottom) {
                            // Landing on top (or hitting ceiling when gravity flipped)
                            player.y = platform.y - player.height;

                            // Apply landing squash if we were falling fast
                            if (player.vy > 5) {
                                player.scaleY = CONFIG.LANDING_SQUASH;
                                player.scaleX = 1 + (1 - CONFIG.LANDING_SQUASH) * 0.5;
                            }

                            player.vy = 0;
                            // Only set onGround if gravity is normal (falling down)
                            if (!player.gravityFlipped) {
                                player.onGround = true;
                            }
                        } else {
                            // Hitting from below (or landing on ceiling when gravity flipped)
                            player.y = platform.y + platform.height;
                            player.vy = 0;
                            // Set onGround if gravity is flipped (falling up)
                            if (player.gravityFlipped) {
                                player.onGround = true;
                            }
                        }
                    }
                }
            }
        }

        // ===========================================
        // TRAP LOGIC
        // ===========================================

        /**
         * Update all traps
         */
        function updateTraps() {
            for (const trap of traps) {
                switch(trap.type) {
                    case 'fallingBlock':
                        updateFallingBlock(trap);
                        break;
                    case 'collapsingPlatform':
                        updateCollapsingPlatform(trap);
                        break;
                    case 'vanishingPlatform':
                        updateVanishingPlatform(trap);
                        break;
                    case 'flyingDoor':
                        updateFlyingDoor(trap);
                        break;
                    case 'spikeWall':
                        updateSpikeWall(trap);
                        break;
                    case 'jumpDetector':
                        updateJumpDetector(trap);
                        break;
                    case 'shrinkButton':
                        updateShrinkButton(trap);
                        break;
                    case 'sizeResetButton':
                        updateSizeResetButton(trap);
                        break;
                    case 'escapingDoor':
                        updateEscapingDoor(trap);
                        break;
                    case 'wallSpikes':
                        updateWallSpikes(trap);
                        break;
                    case 'floorSpikes':
                        updateFloorSpikes(trap);
                        break;
                    case 'launchBlock':
                        updateLaunchBlock(trap);
                        break;
                    case 'ceilingSpikes':
                        updateCeilingSpikes(trap);
                        break;
                    case 'popupSpikes':
                        updatePopupSpikes(trap);
                        break;
                    case 'doorControlButton':
                        updateDoorControlButton(trap);
                        break;
                    case 'playableDoorButton':
                        updatePlayableDoorButton(trap);
                        break;
                    case 'doorJumpTriggerSpikes':
                        updateDoorJumpTriggerSpikes(trap);
                        break;
                    case 'jumpCountPlatform':
                        updateJumpCountPlatform(trap);
                        break;
                    case 'timedBox':
                        updateTimedBox(trap);
                        break;
                    case 'ceilingPopupSpikes':
                        updateCeilingPopupSpikes(trap);
                        break;
                    case 'chaseWall':
                        updateChaseWall(trap);
                        break;
                    case 'meltingDoor':
                        updateMeltingDoor(trap);
                        break;
                    case 'killerDoor':
                        updateKillerDoor(trap);
                        break;
                    case 'flyingFakeDoor':
                        updateFlyingFakeDoor(trap);
                        break;
                    case 'transformingSpikes':
                        updateTransformingSpikes(trap);
                        break;
                    case 'boss':
                        updateBoss(trap);
                        break;
                    case 'shadowButton':
                        updateShadowButton(trap);
                        break;
                    case 'yourFollowerButton':
                        updateYourFollowerButton(trap);
                        break;
                    case 'hiddenPit':
                        updateHiddenPit(trap);
                        break;
                    case 'spikes':
                        updateSpikes(trap);
                        break;
                    case 'ceilingSpikes':
                        // Static ceiling spikes - just check collision
                        if (trap.extended && !player.dead) {
                            const spikeRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                            if (rectsCollide(player, spikeRect)) {
                                killPlayer('crushed');
                            }
                        }
                        break;
                }
            }
        }

        /**
         * Update shadow button - pressed by shadow, not player
         */
        function updateShadowButton(trap) {
            if (trap.pressed || !shadow.active) return;

            // Check if SHADOW is on the button (not player)
            const shadowRect = { x: shadow.x, y: shadow.y, width: player.width, height: player.height };
            const buttonRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };

            if (rectsCollide(shadowRect, buttonRect)) {
                trap.pressed = true;
                // Reveal the real door
                door.x = 720;
                door.y = 340;
            }
        }

        /**
         * Button that player presses to reveal a platform and door
         */
        function updateYourFollowerButton(trap) {
            if (trap.pressed) return;

            const buttonRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
            if (rectsCollide(player, buttonRect)) {
                trap.pressed = true;
                // Reveal the door platform
                if (trap.revealsId) {
                    for (const plat of platforms) {
                        if (plat.id === trap.revealsId) {
                            plat.visible = true;
                        }
                    }
                }
                // Reveal the door
                door.visible = true;
            }
        }

        /**
         * Update hidden pit - looks like floor but player falls through
         */
        function updateHiddenPit(trap) {
            if (!trap.revealed) {
                // Check if player is standing on/in this area
                const playerFeet = player.y + player.height;
                const inPitX = player.x + player.width > trap.x && player.x < trap.x + trap.width;

                if (inPitX && playerFeet >= trap.y && playerFeet <= trap.y + 20) {
                    trap.revealed = true;
                    trap.falling = true;
                    trap.fallY = trap.y;

                    // Split the platform - find the platform at this location and create a hole
                    for (let i = 0; i < platforms.length; i++) {
                        const plat = platforms[i];
                        if (plat.y === trap.y && plat.x <= trap.x && plat.x + plat.width >= trap.x + trap.width) {
                            // Split this platform into two parts around the pit
                            const leftWidth = trap.x - plat.x;
                            const rightStart = trap.x + trap.width;
                            const rightWidth = (plat.x + plat.width) - rightStart;

                            // Hide original platform
                            plat.visible = false;

                            // Add left section if it has width
                            if (leftWidth > 0) {
                                platforms.push({
                                    x: plat.x,
                                    y: plat.y,
                                    width: leftWidth,
                                    height: plat.height
                                });
                            }

                            // Add right section if it has width
                            if (rightWidth > 0) {
                                platforms.push({
                                    x: rightStart,
                                    y: plat.y,
                                    width: rightWidth,
                                    height: plat.height
                                });
                            }
                            break;
                        }
                    }
                }
            }

            // Animate the pit section falling
            if (trap.falling) {
                trap.fallY += 8;
            }
        }

        /**
         * Update basic spikes - just collision detection
         */
        function updateSpikes(trap) {
            if (trap.visible === false || player.dead) return;

            const spikeRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
            if (rectsCollide(player, spikeRect)) {
                killPlayer('crushed');
            }
        }

        /**
         * Update a falling block trap
         */
        function updateFallingBlock(trap) {
            // Check spike collisions on landed blocks with spikes
            if (trap.landed && !player.dead) {
                const spikeReach = 15;

                // Side spikes
                if (trap.hasSideSpikes) {
                    const leftSpikeRect = {
                        x: trap.x - spikeReach,
                        y: trap.y + 10,
                        width: spikeReach + 5,
                        height: trap.height - 20
                    };
                    const rightSpikeRect = {
                        x: trap.x + trap.width - 5,
                        y: trap.y + 10,
                        width: spikeReach + 5,
                        height: trap.height - 20
                    };
                    if (rectsCollide(player, leftSpikeRect) || rectsCollide(player, rightSpikeRect)) {
                        killPlayer('crushed');
                    }
                }

                // Top spikes
                if (trap.hasTopSpikes) {
                    const topSpikeRect = {
                        x: trap.x - 5,
                        y: trap.y - 20,
                        width: trap.width + 10,
                        height: 25
                    };
                    if (rectsCollide(player, topSpikeRect)) {
                        killPlayer('crushed');
                    }
                }
            }

            if (!trap.active || trap.landed) return;

            if (!trap.falling) {
                // Just activated - start falling
                trap.falling = true;
            }

            // Move down extremely fast
            trap.y += trap.speed;

            // Check if landed
            if (trap.y >= trap.landedY) {
                trap.y = trap.landedY;
                trap.falling = false;
                trap.landed = true;
            }

            // Check if crushing player (only if player is alive)
            if (trap.falling && !player.dead) {
                const trapRect = {
                    x: trap.x,
                    y: trap.y,
                    width: trap.width,
                    height: trap.height
                };

                if (rectsCollide(player, trapRect)) {
                    // Player is crushed!
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Update a collapsing platform trap
         * Activates when player stands on it, then falls after a delay
         */
        function updateCollapsingPlatform(trap) {
            if (trap.fallen) return;  // Already gone

            const trapRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            // Check if player is anywhere near the top of this platform
            const playerFeetY = player.y + player.height;
            const playerInRange = player.x + player.width > trap.x &&
                                  player.x < trap.x + trap.width;
            const feetNearSurface = playerFeetY >= trap.y - 5 && playerFeetY <= trap.y + 15;

            // Activate when player touches it - even if they immediately jump off
            if (playerInRange && feetNearSurface && !trap.activated) {
                trap.activated = true;
                trap.timer = trap.delay;
            }

            // Count down and start shaking
            if (trap.activated && !trap.falling) {
                trap.timer -= 16.67;  // Frame time
                trap.shaking = true;

                if (trap.timer <= 0) {
                    trap.falling = true;
                    trap.shaking = false;
                }
            }

            // Fall down
            if (trap.falling) {
                trap.y += trap.fallSpeed;

                // Check if off screen
                if (trap.y > canvas.height + 100) {
                    trap.fallen = true;
                }
            }
        }

        /**
         * Update a vanishing platform trap
         * Disappears when player is airborne within its horizontal zone
         * Only vanishes once - after reappearing, stays solid forever
         */
        function updateVanishingPlatform(trap) {
            // If already triggered once and reappeared, it's now permanently solid
            if (trap.disarmed) return;

            // Check if player is in the air AND within the horizontal trigger zone
            const playerInZone = player.x + player.width > trap.triggerZoneStart &&
                                 player.x < trap.triggerZoneEnd;
            const playerAirborne = !player.onGround;

            if (playerInZone && playerAirborne && !trap.vanished) {
                // Player jumped in the zone - make platform vanish!
                trap.vanished = true;
                trap.reappearTimer = trap.vanishDuration;
            }

            // Count down to reappear
            if (trap.vanished) {
                trap.reappearTimer -= 16.67;
                if (trap.reappearTimer <= 0) {
                    trap.vanished = false;
                    trap.disarmed = true;  // Now it stays solid forever
                }
            }
        }

        /**
         * Update a flying door trap
         * When player is airborne in the zone, door flies away and platform vanishes
         */
        function updateFlyingDoor(trap) {
            if (trap.triggered) {
                // Update platform vanish delay
                if (!trap.platformGone && trap.platformDelay > 0) {
                    trap.platformDelay -= 16.67;
                    if (trap.platformDelay <= 0) {
                        trap.platformGone = true;
                        // Start door animation at the same moment platform disappears
                        doorAnim.active = true;
                        doorAnim.startX = door.x;
                        doorAnim.startY = door.y;
                        doorAnim.targetX = trap.doorTargetX;
                        doorAnim.targetY = trap.doorTargetY;
                        doorAnim.progress = 0;
                        doorAnim.duration = 800;  // Faster animation
                    }
                }
                return;  // Already triggered
            }

            // Check if player is airborne in the trigger zone
            const playerInZone = player.x + player.width > trap.triggerZoneStart &&
                                 player.x < trap.triggerZoneEnd;
            const playerAirborne = !player.onGround;

            if (playerInZone && playerAirborne) {
                // Trigger the trap!
                trap.triggered = true;
                trap.platformDelay = trap.platformVanishDelay;
                // Door animation will start when platform disappears
            }
        }

        /**
         * Update a spike wall trap
         * Rises when triggered, has deadly spikes on top, disappears after 7 seconds
         */
        function updateSpikeWall(trap) {
            if (trap.gone) return;

            if (!trap.active) return;

            // Start rising when activated
            if (!trap.rising && !trap.risen) {
                trap.rising = true;
            }

            // Rise up from ground
            if (trap.rising) {
                trap.y -= trap.riseSpeed;
                if (trap.y <= trap.targetY) {
                    trap.y = trap.targetY;
                    trap.rising = false;
                    trap.risen = true;
                    trap.timer = trap.disappearDelay;
                }
            }

            // Count down to disappear
            if (trap.risen && !trap.disappearing) {
                trap.timer -= 16.67;
                if (trap.timer <= 0) {
                    trap.disappearing = true;
                }
            }

            // Disappear (sink back down)
            if (trap.disappearing) {
                trap.y += trap.riseSpeed;
                if (trap.y >= 400) {
                    trap.gone = true;
                }
            }

            // Check collision with player (only when wall is visible)
            if ((trap.rising || trap.risen) && !trap.disappearing && !player.dead) {
                // Spike zone on top - instant death
                const topSpikeRect = {
                    x: trap.x - 5,
                    y: trap.y - trap.spikeHeight,
                    width: trap.width + 10,
                    height: trap.spikeHeight + 10
                };

                // Spike zones on sides - instant death when running into wall
                const leftSpikeRect = {
                    x: trap.x - 15,
                    y: trap.y + 10,
                    width: 20,
                    height: trap.height - 20
                };

                const rightSpikeRect = {
                    x: trap.x + trap.width - 5,
                    y: trap.y + 10,
                    width: 20,
                    height: trap.height - 20
                };

                // Check if player touches any spikes
                if (rectsCollide(player, topSpikeRect) ||
                    rectsCollide(player, leftSpikeRect) ||
                    rectsCollide(player, rightSpikeRect)) {
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Update a jump detector trap
         * If player jumps at any point, remove the floor and kill them
         */
        function updateJumpDetector(trap) {
            if (trap.triggered) return;

            // Detect if player is jumping (not on ground and moving upward)
            if (!player.onGround && player.vy < 0) {
                trap.triggered = true;
                // Remove the floor platform
                if (trap.floorPlatformIndex !== undefined && platforms[trap.floorPlatformIndex]) {
                    platforms[trap.floorPlatformIndex].y = 1000;  // Move it off screen
                }
            }
        }

        /**
         * Update a shrink button trap
         * When player walks into it, shrink the player with animation
         */
        function updateShrinkButton(trap) {
            if (!trap.visible || trap.activated) return;

            // Check if player overlaps with the button (walking into it)
            const buttonRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, buttonRect)) {
                trap.activated = true;
                // Start shrink animation
                player.shrinking = true;
                player.shrinkTarget = trap.shrinkScale;
                player.shrinkSpeed = (1 - trap.shrinkScale) / (trap.shrinkDuration / 16.67);
            }
        }

        /**
         * Update a size reset button trap
         * When player walks into it, reset player size to normal and disable growth
         */
        function updateSizeResetButton(trap) {
            if (!trap.visible || trap.activated) return;

            // Check if player overlaps with the button
            const buttonRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, buttonRect)) {
                trap.activated = true;
                // Reset player size to normal
                player.sizeScale = 1;
                player.width = CONFIG.PLAYER_WIDTH;
                player.height = CONFIG.PLAYER_HEIGHT;
                // Disable further growth
                player.growthDisabled = true;
            }
        }

        /**
         * Update an escaping door trap
         * Door runs away from player when they get close, gets tired after several escapes
         */
        function updateEscapingDoor(trap) {
            // Initialize stationary timer if not set
            if (trap.stationaryTimer === undefined) trap.stationaryTimer = 0;
            if (trap.lastDoorX === undefined) trap.lastDoorX = door.x;
            if (trap.lastDoorY === undefined) trap.lastDoorY = door.y;

            // Don't run if door animation is already playing
            if (doorAnim.active) {
                trap.stationaryTimer = 0;
                return;
            }

            // Track how long door has been stationary
            if (door.x === trap.lastDoorX && door.y === trap.lastDoorY) {
                trap.stationaryTimer += 16.67;
            } else {
                trap.stationaryTimer = 0;
                trap.lastDoorX = door.x;
                trap.lastDoorY = door.y;
            }

            // Calculate distance to player center
            const doorCenterX = door.x + door.width / 2;
            const doorCenterY = door.y + door.height / 2;
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;

            const dx = doorCenterX - playerCenterX;
            const dy = doorCenterY - playerCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Check if door is stuck in the air (unreachable) for too long
            const isInAir = door.y < 300;
            const stuckTimeout = isInAir ? 2000 : 4000; // 2 sec if in air, 4 sec otherwise
            const isStuck = trap.stationaryTimer > stuckTimeout;

            // Check if player is close enough to trigger escape
            const triggerDistance = trap.triggerDistance - (trap.escapeCount * 8);
            const shouldEscape = (distance < triggerDistance && !player.dead) || isStuck;

            if (shouldEscape) {
                // Door needs to escape (or unstick)!
                if (!isStuck) trap.escapeCount++;

                // Calculate escape position
                let targetX, targetY;

                if (trap.exhausted) {
                    // Already exhausted - tiny hops only
                    const escapeDir = dx > 0 ? 1 : -1;
                    targetX = door.x + escapeDir * (30 + Math.random() * 30);
                    targetY = 340;
                } else if (trap.escapeCount >= trap.maxEscapes) {
                    // Exhausted - make one final short hop, then mark exhausted
                    const escapeDir = dx > 0 ? 1 : -1;
                    targetX = door.x + escapeDir * 60;
                    targetY = 340;
                    trap.exhausted = true;
                } else if (isStuck || isInAir) {
                    // Stuck or in air - must come down to a ground position
                    const groundPoints = trap.escapePoints.filter(p => p.y >= 300);
                    const farPoints = groundPoints.filter(p => {
                        const pointDist = Math.sqrt(Math.pow(p.x - playerCenterX, 2) + Math.pow(p.y - playerCenterY, 2));
                        return pointDist > 120;
                    });
                    if (farPoints.length > 0) {
                        const chosen = farPoints[Math.floor(Math.random() * farPoints.length)];
                        targetX = chosen.x;
                        targetY = chosen.y;
                    } else {
                        // Fallback to opposite side of player
                        targetX = playerCenterX < 400 ? 650 : 100;
                        targetY = 340;
                    }
                } else {
                    // Normal escape - pick from escape points with some randomness
                    const validPoints = trap.escapePoints.filter(p => {
                        const pointDist = Math.sqrt(Math.pow(p.x - playerCenterX, 2) + Math.pow(p.y - playerCenterY, 2));
                        const notCurrentPos = Math.abs(p.x - door.x) > 50 || Math.abs(p.y - door.y) > 50;
                        return pointDist > 130 && notCurrentPos;
                    });

                    if (validPoints.length > 0) {
                        // Sort by distance but pick randomly from top 3 farthest
                        validPoints.sort((a, b) => {
                            const distA = Math.sqrt(Math.pow(a.x - playerCenterX, 2) + Math.pow(a.y - playerCenterY, 2));
                            const distB = Math.sqrt(Math.pow(b.x - playerCenterX, 2) + Math.pow(b.y - playerCenterY, 2));
                            return distB - distA;
                        });
                        const topChoices = validPoints.slice(0, Math.min(3, validPoints.length));
                        const chosen = topChoices[Math.floor(Math.random() * topChoices.length)];
                        targetX = chosen.x;
                        targetY = chosen.y;
                    } else {
                        // All points too close, run opposite direction
                        const escapeDir = dx > 0 ? 1 : -1;
                        targetX = Math.max(50, Math.min(710, door.x + escapeDir * 200));
                        targetY = 340;
                    }
                }

                // Clamp to screen bounds
                targetX = Math.max(20, Math.min(740, targetX));
                targetY = Math.max(50, Math.min(340, targetY));

                // Start door animation
                doorAnim.active = true;
                doorAnim.startX = door.x;
                doorAnim.startY = door.y;
                doorAnim.targetX = targetX;
                doorAnim.targetY = targetY;
                doorAnim.progress = 0;
                // Gets slower as it tires
                doorAnim.duration = 350 + (trap.escapeCount * 100);

                // Reset stationary timer
                trap.stationaryTimer = 0;
            }
        }

        /**
         * Update wall spikes trap - static spikes on a wall that kill on contact
         */
        function updateWallSpikes(trap) {
            if (player.dead) return;

            const spikeRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, spikeRect)) {
                killPlayer('crushed');
            }
        }

        /**
         * Update floor spikes trap - static spikes on the ground that kill on contact
         */
        function updateFloorSpikes(trap) {
            if (player.dead || trap.visible === false) return;

            const spikeRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, spikeRect)) {
                killPlayer('crushed');
            }
        }

        /**
         * Update a launch block - falls like normal, but if player lands on it,
         * it launches upward carrying the player into ceiling spikes
         */
        function updateLaunchBlock(trap) {
            // Handle launching state - player rides the block up
            if (trap.launching) {
                trap.y -= trap.launchSpeed;

                // Force player to ride on top of the block
                if (trap.carryingPlayer && !player.dead) {
                    player.y = trap.y - player.height;
                    player.vy = 0;
                    player.vx = 0;
                    // Center player on block
                    player.x = trap.x + (trap.width - player.width) / 2;
                }

                // Check if reached ceiling
                if (trap.y <= trap.launchTargetY) {
                    trap.y = trap.launchTargetY;
                    trap.launching = false;
                    trap.launched = true;
                }
                return;
            }

            if (!trap.active || trap.launched) return;

            // Falling logic (same as fallingBlock)
            if (!trap.falling && !trap.landed) {
                trap.falling = true;
            }

            if (trap.falling) {
                trap.y += trap.speed;
                if (trap.y >= trap.landedY) {
                    trap.y = trap.landedY;
                    trap.falling = false;
                    trap.landed = true;
                }

                // Check if crushing player while falling
                if (!player.dead) {
                    const trapRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                    if (rectsCollide(player, trapRect)) {
                        killPlayer('crushed');
                    }
                }
            }

            // Check if player lands on top of the block
            if (trap.landed && !trap.launching && !player.dead) {
                const playerFeetY = player.y + player.height;
                const isStandingOn = player.onGround &&
                                     playerFeetY >= trap.y &&
                                     playerFeetY <= trap.y + 5 &&
                                     player.x + player.width > trap.x &&
                                     player.x < trap.x + trap.width;

                if (isStandingOn && trap.launchSpeed > 0) {
                    // Launch the block and carry the player!
                    trap.launching = true;
                    trap.carryingPlayer = true;
                    // Activate linked ceiling spikes
                    if (trap.ceilingSpikeId) {
                        const ceilingSpike = traps.find(t => t.id === trap.ceilingSpikeId);
                        if (ceilingSpike) {
                            ceilingSpike.visible = true;
                        }
                    }
                }
            }
        }

        /**
         * Update ceiling spikes - appear when triggered and kill on contact
         */
        function updateCeilingSpikes(trap) {
            if (!trap.visible || player.dead) return;

            const spikeRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, spikeRect)) {
                killPlayer('crushed');
            }
        }

        /**
         * Update popup spikes - appear from ground when player is airborne over trigger zone
         */
        function updatePopupSpikes(trap) {
            if (player.dead) return;

            // Check if player enters the trigger zone (walking or jumping)
            if (!trap.triggered) {
                const playerInZone = player.x + player.width > trap.triggerZoneStart &&
                                     player.x < trap.triggerZoneEnd;

                if (playerInZone) {
                    trap.triggered = true;
                    trap.visible = true;
                }
            }

            // Check collision if visible
            if (trap.visible) {
                const spikeRect = {
                    x: trap.x,
                    y: trap.y,
                    width: trap.width,
                    height: trap.height
                };

                if (rectsCollide(player, spikeRect)) {
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Update door control button - when touched, player controls the door instead
         */
        function updateDoorControlButton(trap) {
            if (!trap.visible || trap.activated) return;

            const buttonRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, buttonRect)) {
                trap.activated = true;
                doorControl.active = true;
            }
        }

        /**
         * Update playable door button - activates playable door mode (door with physics)
         */
        function updatePlayableDoorButton(trap) {
            if (!trap.visible || trap.activated) return;

            const buttonRect = {
                x: trap.x,
                y: trap.y,
                width: trap.width,
                height: trap.height
            };

            if (rectsCollide(player, buttonRect)) {
                trap.activated = true;
                playableDoor.active = true;
                playableDoor.vx = 0;
                playableDoor.vy = 0;
                playableDoor.onGround = false;
            }
        }

        /**
         * Update door jump trigger spikes - appear when door jumps in zone, disappear after delay
         */
        function updateDoorJumpTriggerSpikes(trap) {
            // Check if spikes should disappear
            if (trap.visible && trap.appearTime) {
                const elapsed = Date.now() - trap.appearTime;
                if (elapsed > trap.disappearDelay) {
                    trap.visible = false;
                    trap.appearTime = null;
                }
            }

            // Check collision with playable door
            if (trap.visible && playableDoor.active && !playableDoor.dead) {
                const spikeRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                const doorRect = { x: door.x, y: door.y, width: door.width, height: door.height };
                if (rectsCollide(doorRect, spikeRect)) {
                    playableDoor.dead = true;
                    playableDoor.deathTimer = 500;
                }
            }
        }

        /**
         * Update jump count platform - disappears after a certain number of jumps
         */
        function updateJumpCountPlatform(trap) {
            if (trap.gone) return;

            // Check if jump count threshold reached
            if (jumpCount >= trap.disappearAfterJump) {
                trap.gone = true;
                // Remove from platforms array by moving off screen
                const platformIndex = platforms.findIndex(p =>
                    p.x === trap.platformX && p.y === trap.platformY
                );
                if (platformIndex !== -1) {
                    platforms[platformIndex].y = 1000;  // Move off screen
                }

                // Trigger door slide if configured (simple linear movement)
                if (trap.slideDoor) {
                    doorSlide.active = true;
                    doorSlide.targetX = trap.doorSlideTargetX || 750;
                    doorSlide.speed = trap.doorSlideSpeed || CONFIG.MOVE_SPEED;
                }
            }
        }

        /**
         * Update timed box - rises up after player touches it once and timer expires
         */
        function updateTimedBox(trap) {
            if (trap.gone) return;

            // If rising, move upward
            if (trap.rising) {
                trap.y -= trap.riseSpeed || 2;
                // Once high enough (off screen), mark as gone
                if (trap.y + trap.height < 0) {
                    trap.gone = true;
                }
                return;
            }

            // Check if player is touching the box - only to trigger the timer once
            if (!trap.touchStartTime) {
                const playerRight = player.x + player.width;
                const playerBottom = player.y + player.height;
                const boxRight = trap.x + trap.width;
                const boxBottom = trap.y + trap.height;

                const touching = player.x < boxRight &&
                                 playerRight > trap.x &&
                                 player.y < boxBottom &&
                                 playerBottom > trap.y;

                if (touching) {
                    trap.touchStartTime = Date.now();
                }
            }

            // Once triggered, check timer regardless of player position
            if (trap.touchStartTime) {
                const elapsed = Date.now() - trap.touchStartTime;
                if (elapsed >= (trap.riseAfterTime || 5000)) {
                    trap.rising = true;
                }
            }
        }

        /**
         * Update ceiling popup spikes - appear when player jumps in a zone
         */
        function updateCeilingPopupSpikes(trap) {
            if (player.dead) return;

            // Check if player is in the trigger zone and jumping (moving upward)
            if (!trap.activated) {
                const inZone = player.x + player.width > trap.triggerZoneStart &&
                              player.x < trap.triggerZoneEnd;

                if (inZone && player.vy < 0) {
                    // Player jumped in the zone - activate the ceiling spikes
                    trap.activated = true;
                    trap.visible = true;
                }
            }

            // Check collision if visible
            if (trap.visible) {
                const spikeRect = {
                    x: trap.x,
                    y: trap.y,
                    width: trap.width,
                    height: trap.height
                };

                if (rectsCollide(player, spikeRect)) {
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Update chase wall - a spike wall that chases the player from the left
         */
        function updateChaseWall(trap) {
            if (!trap.active || player.dead || trap.visible === false) return;

            const levelData = LEVELS[currentLevel];

            // Move the wall to the right
            trap.x += trap.speed;

            // Check if player is in the pit (safe zone - below the wall)
            const alcove = levelData.alcove;
            let inPit = false;
            if (alcove) {
                // Player is safe if they're in the pit area horizontally AND their top is below wall bottom
                const playerTop = player.y;
                const wallBottom = trap.y + trap.height;
                inPit = player.x + player.width > alcove.x &&
                        player.x < alcove.x + alcove.width &&
                        playerTop >= wallBottom;  // Player top is below wall bottom
            }

            // Check collision with player (unless they're safely in the pit)
            if (!inPit) {
                const wallRect = {
                    x: trap.x,
                    y: trap.y,
                    width: trap.width + 20,  // Include spike reach
                    height: trap.height
                };

                if (rectsCollide(player, wallRect)) {
                    killPlayer('crushed');
                }
            }

            // Check if wall smashes the door (troll mechanic!)
            if (trap.smashDoor && !trap.doorSmashed) {
                const wallRight = trap.x + trap.width + 20;  // Include spikes
                if (wallRight >= door.x) {
                    trap.doorSmashed = true;
                    trap.doorSmashAnim = 1;  // Start animation
                    trap.smashX = door.x;
                    trap.smashY = door.y;
                    // Move door off screen (smashed!)
                    door.x = -1000;
                    door.y = -1000;
                }
            }

            // Update door smash animation
            if (trap.doorSmashed && trap.doorSmashAnim > 0) {
                trap.doorSmashAnim -= 0.02;  // Fade out over time
            }

            // Stop the wall when it reaches the right side of canvas
            if (trap.x > canvas.width) {
                trap.active = false;
            }
        }

        /**
         * Update melting door trap
         * When player touches it, it melts and triggers level expansion
         */
        function updateMeltingDoor(trap) {
            if (trap.melted) return;

            // Check if player touches the door
            if (!trap.melting) {
                const doorRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                if (rectsCollide(player, doorRect)) {
                    trap.melting = true;
                    trap.meltProgress = 0;
                }
            }

            // Animate melting
            if (trap.melting && !trap.melted) {
                trap.meltProgress += 0.02;  // Melt over ~50 frames
                if (trap.meltProgress >= 1) {
                    trap.melted = true;
                    trap.melting = false;
                    // Trigger level expansion
                    triggerLevelExpansion(trap.expansionStage);
                }
            }
        }

        /**
         * Update killer door - looks like a normal door but kills on touch
         */
        function updateKillerDoor(trap) {
            if (player.dead || trap.visible === false) return;

            // If trap has been triggered - door flying away and spikes descending
            if (trap.triggered) {
                // Door flies off screen
                if (!trap.doorGone) {
                    trap.doorFlyY -= 15;
                    trap.doorFlyX += trap.doorFlyDir * 8;
                    trap.doorRotation += 0.3;
                    if (trap.doorFlyY < -100) {
                        trap.doorGone = true;
                    }
                }

                // Make edge platforms fall away to create holes
                for (const plat of platforms) {
                    if (plat.id === 'leftEdge' || plat.id === 'rightEdge') {
                        if (!plat.falling) {
                            plat.falling = true;
                            plat.fallSpeed = 0;
                        }
                        plat.fallSpeed += 0.5;  // Gravity
                        plat.y += plat.fallSpeed;
                        // Remove from collision when fallen far enough
                        if (plat.y > 500) {
                            plat.visible = false;
                        }
                    }
                }

                // Ceiling spikes descend
                if (trap.spikeY < 400 && !trap.breakingFloor) {
                    trap.spikeY += 1.9;  // 25% slower

                    // Reached the floor - start waiting
                    if (trap.spikeY >= 400 && !trap.floorWaitStarted) {
                        trap.floorWaitStarted = true;
                        trap.floorWaitTimer = 1000;  // 1 second wait
                    }
                }

                // Wait at floor then break through
                if (trap.floorWaitStarted && !trap.breakingFloor) {
                    trap.floorWaitTimer -= 16.67;
                    if (trap.floorWaitTimer <= 0) {
                        trap.breakingFloor = true;
                        // Hide only the main arena platform (y=400), not the secret room floor (y=600)
                        for (const plat of platforms) {
                            if (plat.y === 400 && !plat.id) {  // Main platform at y=400 with no id
                                plat.visible = false;
                            }
                        }
                    }
                }

                // Continue descending after breaking floor
                if (trap.breakingFloor && trap.spikeY < canvas.height + 50) {
                    trap.spikeY += 2.5;  // Continue down faster
                }

                // Check if spikes hit player
                const spikeBottom = trap.spikeY;
                if (spikeBottom >= player.y && spikeBottom <= player.y + player.height + 50) {
                    killPlayer('crushed');
                }
                return;
            }

            const doorRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
            if (rectsCollide(player, doorRect)) {
                // Simple mode - just kill player instantly (for simpler levels)
                if (trap.simpleKill !== false) {
                    killPlayer('crushed');
                    return;
                }

                // Full animation mode - Door flies away, spikes come down, holes appear
                trap.triggered = true;
                trap.doorGone = false;
                trap.doorFlyX = trap.x;
                trap.doorFlyY = trap.y;
                trap.doorFlyDir = Math.random() < 0.5 ? -1 : 1;  // Random direction
                trap.doorRotation = 0;
                trap.spikeY = -30;  // Start above screen
            }
        }

        /**
         * Update flying fake door - appears, flies away when touched, triggers floor collapse
         */
        function updateFlyingFakeDoor(trap) {
            if (trap.visible === false || trap.gone) return;

            // If flying away
            if (trap.flying) {
                trap.y -= 12;  // Fly upward fast
                trap.flyProgress += 0.05;

                if (trap.y < -100) {
                    trap.gone = true;
                    // Collapse the floor
                    if (trap.collapseFloorIndex !== undefined) {
                        platforms[trap.collapseFloorIndex].visible = false;
                    }
                }
                return;
            }

            // Check if player touches the door
            const doorRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
            if (rectsCollide(player, doorRect)) {
                trap.flying = true;
                trap.flyProgress = 0;
            }
        }

        /**
         * Update transforming spikes - can transform into a door with fancy animation
         */
        function updateTransformingSpikes(trap) {
            if (trap.visible === false) return;

            // Handle transformation animation
            if (trap.transforming) {
                trap.transformProgress += 0.015;  // Slow transformation

                if (trap.transformProgress >= 1) {
                    trap.transforming = false;
                    trap.transformed = true;
                    // Move the real door to this position
                    door.x = trap.x;
                    door.y = trap.y - 35;  // Door is taller than spikes
                }
                return;
            }

            // If not yet transformed, spikes can kill
            if (!trap.transformed && !trap.transforming) {
                const spikeRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                if (rectsCollide(player, spikeRect)) {
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Update boss trap - multi-phase boss fight
         */
        function updateBoss(trap) {
            if (trap.defeated) return;

            const frameTime = 16.67;

            // State machine
            switch (trap.state) {
                case 'standing':
                    // Shoot fireballs at intervals
                    trap.fireballTimer -= frameTime;
                    if (trap.fireballTimer <= 0 && trap.fireballsFired < trap.fireballsToShoot) {
                        // Spawn a fireball - avoid the "ambiguous zone" near player's head
                        // Either clearly above (jump over) or clearly below head (duck or stay)
                        const playerTop = player.y;
                        const playerMid = player.y + player.height / 2;
                        const forbiddenZone = 25;  // Avoid this range around player top

                        let targetY;
                        if (Math.random() < 0.5) {
                            // Low shot - aim at legs/feet (clearly duck under or stay still)
                            targetY = playerMid + 15 + Math.random() * 30;
                        } else {
                            // High shot - aim well above head (clearly jump over)
                            targetY = playerTop - 30 - Math.random() * 40;
                        }
                        targetY = Math.max(250, Math.min(380, targetY));  // Clamp to reasonable range

                        // Aim toward player (left or right)
                        const aimRight = player.x > trap.x;
                        trap.fireballs.push({
                            x: aimRight ? trap.x + 20 : trap.x - 20,
                            y: Math.max(250, Math.min(380, targetY)),  // Clamp to reasonable range
                            vx: aimRight ? 5.5 : -5.5,  // Move toward player
                            width: 25,
                            height: 20
                        });
                        trap.fireballsFired++;
                        trap.fireballTimer = 500 + Math.random() * 700;  // 0.5-1.2 second delay (more time to react)
                    }

                    // After shooting all fireballs, burrow
                    if (trap.fireballsFired >= trap.fireballsToShoot) {
                        trap.state = 'burrowing';
                        trap.burrowProgress = 0;
                    }
                    break;

                case 'burrowing':
                    // Animation: boss sinks into ground
                    trap.burrowProgress += 0.03;
                    if (trap.burrowProgress >= 1) {
                        trap.state = 'burrowed';
                        trap.headX = trap.x;
                        trap.headDirection = -1;  // Start moving left
                    }
                    break;

                case 'burrowed':
                    // Head moves back and forth
                    trap.headX += trap.headSpeed * trap.headDirection;

                    // Bounce off walls (stay within platform: x 70-730)
                    if (trap.headX < 110) {
                        trap.headX = 110;
                        trap.headDirection = 1;
                    } else if (trap.headX > 690) {
                        trap.headX = 690;
                        trap.headDirection = -1;
                    }

                    // Collision detection with player
                    const headRect = {
                        x: trap.headX - 35,
                        y: trap.y + trap.height - 50,
                        width: 70,
                        height: 50
                    };

                    if (rectsCollide(player, headRect)) {
                        // Check if player is above the head (jumping on it)
                        const playerBottom = player.y + player.height;
                        const headTop = headRect.y;

                        if (player.vy > 0 && playerBottom < headTop + 25) {
                            // Player jumped on the head!
                            trap.health--;
                            player.vy = -12;  // Bounce up

                            if (trap.health <= 0) {
                                // Boss defeated!
                                trap.state = 'dying';
                                trap.deathProgress = 0;
                            } else {
                                // Boss gets back up, more fireballs next time
                                trap.state = 'emerging';
                                trap.burrowProgress = 1;
                                trap.fireballsToShoot += 2;  // Increase difficulty
                                trap.fireballsFired = 0;
                            }
                        } else {
                            // Hit from the side - player dies
                            killPlayer('crushed');
                        }
                    }
                    break;

                case 'emerging':
                    // Animation: boss rises from ground
                    trap.burrowProgress -= 0.025;
                    if (trap.burrowProgress <= 0) {
                        trap.burrowProgress = 0;
                        trap.state = 'standing';
                        trap.fireballTimer = 1000;  // Brief pause before shooting
                    }
                    break;

                case 'dying':
                    // Death animation
                    trap.deathProgress += 0.02;
                    if (trap.deathProgress >= 1) {
                        trap.defeated = true;
                        trap.visible = false;
                        // Trigger the fake door to appear
                        for (const t of traps) {
                            if (t.type === 'killerDoor' && t.bossVictoryDoor) {
                                t.visible = true;
                            }
                        }
                    }
                    break;
            }

            // Update fireballs
            for (let i = trap.fireballs.length - 1; i >= 0; i--) {
                const fb = trap.fireballs[i];
                fb.x += fb.vx;

                // Check collision with player
                if (rectsCollide(player, fb)) {
                    killPlayer('crushed');
                }

                // Remove if off screen (either side)
                if (fb.x < -50 || fb.x > 850) {
                    trap.fireballs.splice(i, 1);
                }
            }

            // Standing boss collision (can't jump on, too tall)
            if (trap.state === 'standing' || trap.state === 'emerging') {
                const standingRect = {
                    x: trap.x - 40,
                    y: trap.y,
                    width: 80,
                    height: trap.height * (1 - trap.burrowProgress)
                };
                if (rectsCollide(player, standingRect)) {
                    killPlayer('crushed');
                }
            }
        }

        /**
         * Trigger level expansion - widen/heighten the canvas and reveal new areas
         */
        function triggerLevelExpansion(targetStage) {
            const levelData = LEVELS[currentLevel];
            if (!levelData.expansions || !levelData.expansions[targetStage]) return;

            const expansion = levelData.expansions[targetStage];
            levelExpansion.stage = targetStage;
            levelExpansion.expanding = true;
            levelExpansion.expandProgress = 0;
            levelExpansion.targetWidth = expansion.canvasWidth || canvas.width;
            levelExpansion.targetHeight = expansion.canvasHeight || canvas.height;

            // Reveal platforms for this expansion stage
            for (const plat of platforms) {
                if (plat.revealStage === targetStage) {
                    plat.visible = true;
                }
            }

            // Reveal/activate traps for this expansion stage
            for (const trap of traps) {
                if (trap.revealStage === targetStage) {
                    trap.visible = true;
                    // Activate chase walls when revealed
                    if (trap.type === 'chaseWall') {
                        trap.active = true;
                    }
                }
            }

            // Update the real door position if this expansion has one
            if (expansion.newDoor) {
                door.x = expansion.newDoor.x;
                door.y = expansion.newDoor.y;
            }
        }

        /**
         * Update level expansion animation
         */
        function updateLevelExpansion() {
            if (!levelExpansion.expanding) return;

            levelExpansion.expandProgress += 0.03;  // Smooth expansion

            // Interpolate canvas width
            const targetWidth = levelExpansion.targetWidth;
            const newWidth = canvas.width + (targetWidth - canvas.width) * 0.1;

            // Interpolate canvas height
            const targetHeight = levelExpansion.targetHeight;
            const newHeight = canvas.height + (targetHeight - canvas.height) * 0.1;

            const widthDone = Math.abs(newWidth - targetWidth) < 1;
            const heightDone = Math.abs(newHeight - targetHeight) < 1;

            if (widthDone && heightDone) {
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                levelExpansion.expanding = false;
            } else {
                if (!widthDone) canvas.width = Math.round(newWidth);
                if (!heightDone) canvas.height = Math.round(newHeight);
            }
        }

        /**
         * Update player shrink animation
         */
        function updatePlayerShrink() {
            if (!player.shrinking) return;

            // Gradually shrink the player
            const currentScale = player.width / CONFIG.PLAYER_WIDTH;

            if (currentScale > player.shrinkTarget) {
                const newScale = Math.max(player.shrinkTarget, currentScale - player.shrinkSpeed);

                // Store old bottom position
                const oldBottom = player.y + player.height;

                // Update dimensions
                player.width = CONFIG.PLAYER_WIDTH * newScale;
                player.height = CONFIG.PLAYER_HEIGHT * newScale;

                // Keep feet on ground (adjust y so bottom stays same)
                player.y = oldBottom - player.height;

                // Add some sparkle effect by pulsing scale
                if (Math.random() < 0.3) {
                    player.scaleX = 1 + (Math.random() - 0.5) * 0.2;
                    player.scaleY = 1 + (Math.random() - 0.5) * 0.2;
                }
            } else {
                // Shrinking complete
                player.shrinking = false;
                player.scaleX = 1;
                player.scaleY = 1;
            }
        }

        /**
         * Update door animation (called from main update)
         */
        function updateDoorAnimation() {
            if (!doorAnim.active) return;

            // Advance progress
            doorAnim.progress += 16.67 / doorAnim.duration;

            if (doorAnim.progress >= 1) {
                // Animation complete
                doorAnim.progress = 1;
                doorAnim.active = false;
                door.x = doorAnim.targetX;
                door.y = doorAnim.targetY;
            } else {
                // Animate with arc motion
                // First 15%: go up fast, then arc over to target
                const p = doorAnim.progress;

                if (p < 0.15) {
                    // Phase 1: Rise up fast (go high to avoid player collision)
                    // Use ease-out for fast start
                    const riseProgress = p / 0.15;
                    const easedRise = 1 - Math.pow(1 - riseProgress, 2);
                    door.x = doorAnim.startX;
                    door.y = doorAnim.startY - (280 * easedRise);
                } else {
                    // Phase 2: Arc to target
                    const arcProgress = (p - 0.15) / 0.85;
                    // Smooth easing
                    const eased = 1 - Math.pow(1 - arcProgress, 2);

                    const peakY = doorAnim.startY - 280;
                    door.x = doorAnim.startX + (doorAnim.targetX - doorAnim.startX) * eased;
                    // Arc down from peak to target
                    door.y = peakY + (doorAnim.targetY - peakY) * eased;
                }
            }
        }

        /**
         * Check and activate triggers
         */
        function checkTriggers() {
            for (const trigger of triggers) {
                if (trigger.triggered) continue;

                let shouldTrigger = false;

                // Proximity trigger - checks both X and Y distance
                if (trigger.type === 'proximity') {
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const dx = Math.abs(playerCenterX - trigger.x);
                    const dy = Math.abs(playerCenterY - trigger.y);
                    const proximityX = trigger.proximityX || 50;
                    const proximityY = trigger.proximityY || 50;
                    shouldTrigger = dx < proximityX && dy < proximityY;
                } else if (trigger.type === 'heightReached') {
                    // Height trigger - activates when player's feet reach a certain height
                    // Optionally also checks X position
                    const playerFeet = player.y + player.height;
                    const playerCenterX = player.x + player.width / 2;
                    const heightOk = playerFeet <= trigger.maxY;
                    const xOk = (trigger.minX === undefined || playerCenterX >= trigger.minX) &&
                                (trigger.maxX === undefined || playerCenterX <= trigger.maxX);
                    shouldTrigger = heightOk && xOk;
                } else if (trigger.type === 'pitFall') {
                    // Pit fall trigger - activates when player falls past Y threshold in X range
                    const playerCenterX = player.x + player.width / 2;
                    const inXRange = playerCenterX >= trigger.xMin && playerCenterX <= trigger.xMax;
                    const pastY = player.y > trigger.y;
                    shouldTrigger = inXRange && pastY;

                    // Check if trap door must be triggered first (holes must exist)
                    if (shouldTrigger && trigger.requiresTrapTriggered) {
                        const killerDoor = traps.find(t => t.type === 'killerDoor' && t.bossVictoryDoor);
                        if (!killerDoor || !killerDoor.triggered) {
                            // Trap not triggered yet - this shouldn't happen since platform is solid
                            shouldTrigger = false;
                        }
                    }

                    // Check if boss must be defeated first
                    if (shouldTrigger && trigger.requiresBossDefeated) {
                        const boss = traps.find(t => t.type === 'boss');
                        if (!boss || !boss.defeated) {
                            // Boss not defeated - player dies in the pit
                            if (!player.dead) {
                                killPlayer('fallen');
                            }
                            shouldTrigger = false;
                        }
                    }
                } else {
                    // Default: check if player crossed the trigger X point
                    shouldTrigger = player.x + player.width > trigger.x;
                }

                if (shouldTrigger) {
                    // Check if this trigger requires another trap to be visible first
                    if (trigger.requiresTrapVisible) {
                        const requiredTrap = traps.find(t => t.id === trigger.requiresTrapVisible);
                        if (!requiredTrap || !requiredTrap.visible) {
                            continue;  // Required trap not visible yet
                        }
                    }

                    // Handle delayed triggers
                    if (trigger.delay && trigger.delay > 0) {
                        if (!trigger.delayStarted) {
                            trigger.delayStarted = true;
                            trigger.delayTimer = trigger.delay;
                        }
                        // Count down the delay
                        trigger.delayTimer -= 16.67;
                        if (trigger.delayTimer > 0) {
                            continue;  // Still waiting
                        }
                    }

                    trigger.triggered = true;

                    switch(trigger.action) {
                        case 'activateTrap':
                            const trap = traps.find(t => t.id === trigger.trapId);
                            if (trap) {
                                trap.active = true;
                            }
                            break;
                        case 'showShrinkButton':
                            const buttonTrap = traps.find(t => t.id === trigger.trapId);
                            if (buttonTrap) {
                                buttonTrap.visible = true;
                            }
                            break;
                        case 'showDoorControlButton':
                            // Only show if player hasn't jumped yet
                            if (jumpCount === 0) {
                                const doorButtonTrap = traps.find(t => t.id === trigger.trapId);
                                if (doorButtonTrap) {
                                    doorButtonTrap.visible = true;
                                }
                            }
                            break;
                        case 'showSizeResetButton':
                            const resetButtonTrap = traps.find(t => t.id === trigger.trapId);
                            if (resetButtonTrap) {
                                resetButtonTrap.visible = true;
                            }
                            break;
                        case 'showTrap':
                            const showTrap = traps.find(t => t.id === trigger.trapId);
                            if (showTrap) {
                                showTrap.visible = true;
                            }
                            break;
                        case 'startTransformation':
                            const transformTrap = traps.find(t => t.id === trigger.trapId);
                            if (transformTrap) {
                                transformTrap.transforming = true;
                                transformTrap.transformProgress = 0;
                            }
                            break;
                        case 'expandDown':
                            // Expand the level downward and reveal secret room
                            triggerLevelExpansion(1);
                            // Add secret platforms
                            const levelData = LEVELS[currentLevel];
                            if (levelData.secretPlatforms) {
                                for (const plat of levelData.secretPlatforms) {
                                    platforms.push({...plat, visible: true});
                                }
                            }
                            break;
                        case 'doorFlyAway':
                            // Door flies away to target position
                            doorAnim.active = true;
                            doorAnim.startX = door.x;
                            doorAnim.startY = door.y;
                            doorAnim.targetX = trigger.targetX;
                            doorAnim.targetY = trigger.targetY;
                            doorAnim.progress = 0;
                            doorAnim.duration = 800;
                            // Show the playable door button after a delay
                            setTimeout(() => {
                                const pdButton = traps.find(t => t.id === 'playableDoorButton');
                                if (pdButton) pdButton.visible = true;
                            }, 1000);
                            break;
                    }
                }
            }
        }

        // ===========================================
        // RUNNER MODE (Subway Surfer style)
        // ===========================================

        /**
         * Spike Control Mode - player controls the spike instead of the character
         */
        function updateSpikeControlMode() {
            // Find the spike and enemy
            let spike = null;
            let enemy = null;
            for (const trap of traps) {
                if (trap.type === 'yourSpike') spike = trap;
                if (trap.type === 'yourEnemy') enemy = trap;
            }
            if (!spike) return;

            // Control the spike with arrow keys
            const spikeSpeed = 5;
            if (keys.left) spike.vx = -spikeSpeed;
            else if (keys.right) spike.vx = spikeSpeed;
            else spike.vx = 0;

            // Spike jumping
            if (keys.up && spike.onGround) {
                spike.vy = -12;
                spike.onGround = false;
            }

            // Apply gravity to spike
            spike.vy += 0.6;
            if (spike.vy > 10) spike.vy = 10;

            // Move spike
            spike.x += spike.vx;
            spike.y += spike.vy;

            // Spike ground collision
            const groundY = 400;
            if (spike.y + spike.height > groundY) {
                spike.y = groundY - spike.height;
                spike.vy = 0;
                spike.onGround = true;
            }

            // Spike screen bounds
            if (spike.x < 0) spike.x = 0;
            if (spike.x + spike.width > canvas.width) spike.x = canvas.width - spike.width;

            // Enemy walks slowly toward player
            if (enemy && enemy.alive) {
                enemy.x -= 0.5;  // Slow walk toward player (left)

                // Check if enemy touches player - kills player!
                const enemyRect = { x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height };
                const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
                if (rectsCollide(enemyRect, playerRect)) {
                    killPlayer('crushed');
                    return;
                }

                // Check spike collision with enemy
                const spikeRect = { x: spike.x, y: spike.y, width: spike.width, height: spike.height };
                if (rectsCollide(spikeRect, enemyRect)) {
                    enemy.alive = false;
                    spikeControl.enemyDead = true;
                    spikeControl.playerAutoWalk = true;
                }
            }

            // Check spike collision with door (kills door!)
            if (!spikeControl.doorDead) {
                const spikeRect = { x: spike.x, y: spike.y, width: spike.width, height: spike.height };
                if (rectsCollide(spikeRect, door)) {
                    spikeControl.doorDead = true;
                    // Create door fragments for explosion
                    for (let i = 0; i < 12; i++) {
                        spikeControl.doorFragments.push({
                            x: door.x + door.width/2,
                            y: door.y + door.height/2,
                            vx: (Math.random() - 0.5) * 10,
                            vy: (Math.random() - 0.7) * 8,
                            size: 5 + Math.random() * 10,
                            rotation: Math.random() * Math.PI * 2,
                            rotSpeed: (Math.random() - 0.5) * 0.3
                        });
                    }
                }
            }

            // Update door death animation
            if (spikeControl.doorDead) {
                spikeControl.doorDeathAnim += 0.02;
                for (const frag of spikeControl.doorFragments) {
                    frag.x += frag.vx;
                    frag.y += frag.vy;
                    frag.vy += 0.3;  // Gravity
                    frag.rotation += frag.rotSpeed;
                }
            }

            // Player auto-walks when enemy is dead
            if (spikeControl.playerAutoWalk) {
                if (spikeControl.doorDead) {
                    // Walk toward spike
                    if (spike.x > player.x + player.width/2) {
                        player.x += 3;
                    } else {
                        player.x -= 3;
                    }
                } else {
                    player.x += 3;  // Walk right toward door
                }
            }

            // Check spike collision with player (kills player!)
            const spikeRect = { x: spike.x, y: spike.y, width: spike.width, height: spike.height };
            const playerRect = { x: player.x, y: player.y, width: player.width, height: player.height };
            if (rectsCollide(spikeRect, playerRect)) {
                killPlayer('crushed');
                return;
            }

            // Check if player reached door (and door is alive)
            if (!spikeControl.doorDead && rectsCollide(player, door)) {
                levelComplete = true;
            }
        }

        function updateRunner() {
            const levelData = LEVELS[currentLevel];
            if (!levelData.isRunnerLevel || !runner.active) return;

            // Update timer
            runner.timer += 16.67;

            // Lane switching - smooth movement
            const lanePositions = [250, 400, 550];  // X positions for 3 lanes
            runner.targetLane = Math.max(0, Math.min(2, runner.targetLane));
            const targetX = lanePositions[runner.targetLane];
            runner.laneX += (targetX - runner.laneX) * 0.2;  // Smooth interpolation

            // Check if collected enough coins (15 coins = goal)
            if (runner.coinsCollected >= 15 && !runner.doorApproaching) {
                runner.doorApproaching = true;
                runner.doorZ = 1000;
            }

            // Move door closer
            if (runner.doorApproaching) {
                runner.doorZ -= runner.speed * 1.5;
                if (runner.doorZ <= 50) {
                    // Reached the door!
                    levelComplete = true;
                }
            }

            // Spawn obstacles randomly (but ensure there's always a safe path!)
            if (Math.random() < 0.018 && !runner.doorApproaching) {  // Slightly lower spawn rate
                // Check which lanes have obstacles in the danger zone (wide range to ensure dodgeable)
                const blockedLanes = new Set();
                for (const obs of runner.obstacles) {
                    if (obs.z > 700) {  // Check a wider range for better spacing
                        blockedLanes.add(obs.lane);
                    }
                }

                // Only spawn if it won't block all 3 lanes
                if (blockedLanes.size < 2) {
                    // Safe to spawn in any lane
                    runner.obstacles.push({
                        lane: Math.floor(Math.random() * 3),
                        z: 1000,
                        type: 'spike'
                    });
                } else if (blockedLanes.size === 2) {
                    // Two lanes blocked - spawn in an already-blocked lane (don't block the third!)
                    const blockedArray = Array.from(blockedLanes);
                    runner.obstacles.push({
                        lane: blockedArray[Math.floor(Math.random() * blockedArray.length)],
                        z: 1000,
                        type: 'spike'
                    });
                }
                // If all 3 are blocked somehow, don't spawn anything
            }

            // Spawn coins randomly
            if (Math.random() < 0.04 && !runner.doorApproaching) {
                runner.coins.push({
                    lane: Math.floor(Math.random() * 3),
                    z: 1000
                });
            }

            // Spawn falling boxes occasionally
            if (Math.random() < 0.008 && !runner.doorApproaching) {
                runner.fallingBoxes.push({
                    lane: Math.floor(Math.random() * 3),
                    y: -50,
                    z: 300 + Math.random() * 200,
                    vy: 0
                });
            }

            // Update obstacles
            for (let i = runner.obstacles.length - 1; i >= 0; i--) {
                const obs = runner.obstacles[i];
                obs.z -= runner.speed;

                // Collision check (when obstacle is close) - forgiving hitbox
                if (obs.z < 60 && obs.z > 35) {
                    if (obs.lane === runner.targetLane) {
                        killPlayer('crushed');
                        return;
                    }
                }

                // Remove if past player
                if (obs.z < 0) {
                    runner.obstacles.splice(i, 1);
                }
            }

            // Update coins
            for (let i = runner.coins.length - 1; i >= 0; i--) {
                const coin = runner.coins[i];
                coin.z -= runner.speed;

                // Collect coin
                if (coin.z < 80 && coin.z > 20) {
                    if (coin.lane === runner.targetLane) {
                        runner.coinsCollected++;
                        runner.coins.splice(i, 1);
                        continue;
                    }
                }

                // Remove if past player
                if (coin.z < 0) {
                    runner.coins.splice(i, 1);
                }
            }

            // Update falling boxes
            for (let i = runner.fallingBoxes.length - 1; i >= 0; i--) {
                const box = runner.fallingBoxes[i];
                box.vy += 0.5;  // Gravity
                box.y += box.vy;
                box.z -= runner.speed * 0.3;  // Slowly approach too

                // Check if landed (and in player's lane)
                if (box.y > 350 && box.z < 100 && box.z > 20) {
                    if (box.lane === runner.targetLane) {
                        killPlayer('crushed');
                        return;
                    }
                }

                // Remove if off screen
                if (box.y > 500 || box.z < 0) {
                    runner.fallingBoxes.splice(i, 1);
                }
            }
        }

        function renderRunner() {
            const levelData = LEVELS[currentLevel];
            if (!levelData.isRunnerLevel || !runner.active) return;

            // Clear with sky gradient
            const skyGrad = ctx.createLinearGradient(0, 0, 0, 450);
            skyGrad.addColorStop(0, '#87CEEB');
            skyGrad.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, 800, 450);

            // Vanishing point
            const vpX = 400;
            const vpY = 150;

            // Draw ground with perspective
            const groundGrad = ctx.createLinearGradient(0, vpY, 0, 450);
            groundGrad.addColorStop(0, '#888888');
            groundGrad.addColorStop(1, '#666666');
            ctx.fillStyle = groundGrad;
            ctx.beginPath();
            ctx.moveTo(vpX, vpY);
            ctx.lineTo(800, 450);
            ctx.lineTo(0, 450);
            ctx.closePath();
            ctx.fill();

            // Draw lane dividers
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            for (let i = 0; i <= 3; i++) {
                const topX = vpX + (i - 1.5) * 30;
                const bottomX = 100 + i * 200;
                ctx.beginPath();
                ctx.moveTo(topX, vpY);
                ctx.lineTo(bottomX, 450);
                ctx.stroke();
            }


            // Helper: get screen position from lane and z
            function getScreenPos(lane, z) {
                const t = 1 - (z / 1000);  // 0 at horizon, 1 at player
                const laneOffset = (lane - 1) * (30 + t * 120);
                const x = vpX + laneOffset;
                const y = vpY + t * 280;
                const scale = 0.1 + t * 0.9;
                return { x, y, scale };
            }

            // Draw obstacles (sorted by z for proper depth)
            const allObjects = [
                ...runner.obstacles.map(o => ({...o, objType: 'obstacle'})),
                ...runner.coins.map(c => ({...c, objType: 'coin'}))
            ].sort((a, b) => b.z - a.z);

            for (const obj of allObjects) {
                const pos = getScreenPos(obj.lane, obj.z);

                if (obj.objType === 'obstacle') {
                    // Draw spike
                    const spikeWidth = 40 * pos.scale;
                    const spikeHeight = 30 * pos.scale;
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(pos.x - spikeWidth/2, pos.y);
                    ctx.lineTo(pos.x, pos.y - spikeHeight);
                    ctx.lineTo(pos.x + spikeWidth/2, pos.y);
                    ctx.closePath();
                    ctx.fill();
                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    ctx.beginPath();
                    ctx.moveTo(pos.x - spikeWidth/4, pos.y - 2);
                    ctx.lineTo(pos.x, pos.y - spikeHeight + 5);
                    ctx.lineTo(pos.x + spikeWidth/8, pos.y - 2);
                    ctx.closePath();
                    ctx.fill();
                } else if (obj.objType === 'coin') {
                    // Draw coin
                    const coinSize = 15 * pos.scale;
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - coinSize, coinSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#FFA500';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - coinSize, coinSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw falling boxes
            for (const box of runner.fallingBoxes) {
                const pos = getScreenPos(box.lane, box.z);
                const boxSize = 35 * pos.scale;
                const boxY = box.y * pos.scale + vpY * (1 - pos.scale);
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(pos.x - boxSize/2, boxY - boxSize, boxSize, boxSize);
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(pos.x - boxSize/2, boxY - boxSize, boxSize, boxSize);
                // Warning indicator
                if (box.y < 100) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y - 10, 10 * pos.scale, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw approaching door
            if (runner.doorApproaching) {
                const doorPos = getScreenPos(1, runner.doorZ);  // Center lane
                const doorWidth = 40 * doorPos.scale;
                const doorHeight = 60 * doorPos.scale;
                ctx.fillStyle = CONFIG.DOOR_COLOR;
                ctx.fillRect(doorPos.x - doorWidth/2, doorPos.y - doorHeight, doorWidth, doorHeight);
                ctx.fillStyle = '#3a9a5a';
                ctx.beginPath();
                ctx.arc(doorPos.x + doorWidth/4, doorPos.y - doorHeight/2, 4 * doorPos.scale, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw player (from behind)
            const playerX = runner.laneX;
            let playerY = 380;
            const playerW = 30;
            const playerH = 50;

            // Death animation
            if (player.dead && runner.deathType) {
                // Player tumbles and flies off screen
                const deathY = playerY + runner.deathVY * runner.deathAnim * 30;

                ctx.save();
                ctx.translate(playerX, deathY - playerH/2);
                ctx.rotate(runner.deathRotation);

                // Body (tumbling)
                ctx.fillStyle = CONFIG.PLAYER_COLOR;
                ctx.fillRect(-playerW/2, -playerH/2, playerW, playerH);

                // Head
                ctx.beginPath();
                ctx.arc(0, -playerH/2 - 12, 12, 0, Math.PI * 2);
                ctx.fill();

                // Arms (flailing)
                const armFlail = Math.sin(runner.deathAnim * 20) * 15;
                ctx.fillRect(-playerW/2 - 8, -playerH/2 + 5 + armFlail, 8, 25);
                ctx.fillRect(playerW/2, -playerH/2 + 5 - armFlail, 8, 25);

                // Legs (flailing)
                const legFlail = Math.sin(runner.deathAnim * 25) * 12;
                ctx.fillRect(-10, playerH/2 - 20, 8, 20 + legFlail);
                ctx.fillRect(2, playerH/2 - 20, 8, 20 - legFlail);

                ctx.restore();

                // Draw "OUCH!" text
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('OUCH!', 400, 200);
                ctx.textAlign = 'left';
            } else {
                // Normal player rendering
                // Body
                ctx.fillStyle = CONFIG.PLAYER_COLOR;
                ctx.fillRect(playerX - playerW/2, playerY - playerH, playerW, playerH);

                // Head
                ctx.beginPath();
                ctx.arc(playerX, playerY - playerH - 12, 12, 0, Math.PI * 2);
                ctx.fill();

                // Arms (swinging animation)
                const armSwing = Math.sin(runner.timer / 100) * 10;
                ctx.fillRect(playerX - playerW/2 - 8, playerY - playerH + 5 + armSwing, 8, 25);
                ctx.fillRect(playerX + playerW/2, playerY - playerH + 5 - armSwing, 8, 25);

                // Legs (running animation)
                const legSwing = Math.sin(runner.timer / 80) * 8;
                ctx.fillRect(playerX - 10, playerY - 5, 8, 20 + legSwing);
                ctx.fillRect(playerX + 2, playerY - 5, 8, 20 - legSwing);
            }

            // Draw coin counter
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px Arial';
            ctx.fillText(' ' + runner.coinsCollected, 20, 30);
        }

        // ===========================================
        // GAME UPDATE
        // ===========================================

        function update() {
            if (levelComplete) {
                if (!transitioning) {
                    transitioning = true;
                    setTimeout(nextLevel, 500);
                }
                return;
            }

            // Handle death state
            if (player.dead) {
                player.deathTimer -= 16.67;  // Approximate frame time at 60fps

                // Update runner death animation
                if (LEVELS[currentLevel].isRunnerLevel && runner.active) {
                    runner.deathAnim += 0.02;
                    runner.deathVY += 0.8;  // Gravity
                    runner.deathRotation += 0.15;  // Tumble
                    runner.laneX += runner.deathVX;
                }

                if (player.deathTimer <= 0) {
                    restartLevel();
                }

                // For runner levels, we still need to render the death animation
                if (LEVELS[currentLevel].isRunnerLevel && runner.active) {
                    renderRunner();
                }
                return;  // Skip normal updates while dead
            }

            // Runner mode - completely different gameplay
            if (LEVELS[currentLevel].isRunnerLevel && runner.active) {
                updateRunner();
                return;  // Skip normal platformer update
            }

            // Spike control mode - you control the spike, not the player
            if (spikeControl.active) {
                updateSpikeControlMode();
                return;  // Skip normal platformer update
            }

            // Portal level teleport animation
            if (portalState.teleporting) {
                portalState.teleportAnim += 0.05;
                if (portalState.teleportAnim >= 1) {
                    // Teleport complete - move player to portal door
                    const portalDoor = traps.find(t => t.type === 'portalDoor');
                    if (portalDoor) {
                        player.x = portalDoor.x + portalDoor.width + 5;
                        player.y = portalDoor.y + portalDoor.height - player.height;
                        player.vx = 2;  // Small push out of door
                        player.vy = 0;
                    }
                    portalState.teleporting = false;
                    portalState.teleported = true;
                    portalState.exitedPortalDoor = false;  // Reset so win condition works
                    portalState.teleportAnim = 0;
                }
                return;  // Skip normal update during teleport
            }

            // Update invisibility based on streetlamp light cone
            if (LEVELS[currentLevel].playerInvisible) {
                // Find the streetlamp trap
                const streetlamp = traps.find(t => t.type === 'streetlamp');
                if (streetlamp) {
                    // Check if player center is within the light cone
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const lampX = streetlamp.x;
                    const lampY = streetlamp.y;
                    const groundY = 400;

                    // Calculate cone width at player's Y position
                    // Cone goes from lightConeTop at lamp to lightRadius at ground
                    const coneProgress = (playerCenterY - (lampY + 30)) / (groundY - (lampY + 30));
                    const coneWidthAtPlayer = streetlamp.lightConeTop +
                        (streetlamp.lightRadius - streetlamp.lightConeTop) * Math.max(0, Math.min(1, coneProgress));

                    // Check if player is within the cone horizontally and below the lamp
                    const distFromLamp = Math.abs(playerCenterX - lampX);
                    const inLightCone = playerCenterY > lampY + 30 && distFromLamp < coneWidthAtPlayer;

                    // Update visibility with smooth transition
                    if (inLightCone) {
                        player.invisibleAnim = Math.max(0, player.invisibleAnim - 0.1);  // Fade in
                        player.invisible = false;
                    } else {
                        player.invisibleAnim = Math.min(1, player.invisibleAnim + 0.05);  // Fade out
                        if (player.invisibleAnim >= 1) {
                            player.invisible = true;
                        }
                    }
                }
            }

            // Check if current level has swapped controls
            const levelData = LEVELS[currentLevel];
            const swapLeftRight = levelData.swapLeftRight || false;
            const jumpWithDown = levelData.jumpWithDown || false;

            // Determine effective input based on control swap
            const effectiveLeft = swapLeftRight ? keys.right : keys.left;
            const effectiveRight = swapLeftRight ? keys.left : keys.right;
            const effectiveJump = jumpWithDown ? keys.down : keys.up;

            // Door control mode - player controls the door instead
            if (doorControl.active) {
                // Move door with arrow keys
                if (effectiveLeft) {
                    door.x -= doorControl.speed;
                }
                if (effectiveRight) {
                    door.x += doorControl.speed;
                }
                if (keys.up) {
                    door.y -= doorControl.speed;
                }
                if (keys.down) {
                    door.y += doorControl.speed;
                }
                // Clamp door to screen
                door.x = Math.max(0, Math.min(canvas.width - door.width, door.x));
                door.y = Math.max(0, Math.min(canvas.height - door.height, door.y));

                // Player stays still but gravity still applies
                player.vx = 0;
            } else if (playableDoor.active && !playableDoor.dead) {
                // Playable door mode - door moves like a player with physics!
                // Player stays still
                player.vx = 0;

                // Door horizontal movement
                if (effectiveLeft) {
                    playableDoor.vx = -CONFIG.MOVE_SPEED;
                    playableDoor.facingRight = false;
                } else if (effectiveRight) {
                    playableDoor.vx = CONFIG.MOVE_SPEED;
                    playableDoor.facingRight = true;
                } else {
                    playableDoor.vx = 0;
                }

                // Door jumping
                if (effectiveJump && playableDoor.onGround) {
                    playableDoor.vy = CONFIG.JUMP_FORCE;
                    playableDoor.onGround = false;
                    // Apply jump stretch
                    playableDoor.scaleY = CONFIG.JUMP_STRETCH;
                    playableDoor.scaleX = 1 / CONFIG.JUMP_STRETCH;

                    // Check for doorJumpTriggerSpikes - appear when door jumps in trigger zone
                    for (const trap of traps) {
                        if (trap.type === 'doorJumpTriggerSpikes' && !trap.visible) {
                            // Check if door is in the trigger zone
                            if (door.x + door.width > trap.triggerZoneX) {
                                trap.visible = true;
                                trap.appearTime = Date.now();
                            }
                        }
                    }
                }

                // Apply gravity to door
                playableDoor.vy += CONFIG.GRAVITY;
                if (playableDoor.vy > CONFIG.MAX_FALL_SPEED) {
                    playableDoor.vy = CONFIG.MAX_FALL_SPEED;
                }

                // Move door
                door.x += playableDoor.vx;
                door.y += playableDoor.vy;

                // Door platform collision
                playableDoor.onGround = false;
                for (const plat of platforms) {
                    if (plat.visible === false) continue;
                    const doorRect = { x: door.x, y: door.y, width: door.width, height: door.height };
                    if (rectsCollide(doorRect, plat)) {
                        // Landing on top
                        if (playableDoor.vy > 0 && door.y + door.height - playableDoor.vy <= plat.y) {
                            door.y = plat.y - door.height;
                            playableDoor.vy = 0;
                            if (!playableDoor.onGround) {
                                // Landing squash
                                playableDoor.scaleY = CONFIG.LAND_SQUASH;
                                playableDoor.scaleX = 1 / CONFIG.LAND_SQUASH;
                            }
                            playableDoor.onGround = true;
                        }
                    }
                }

                // Clamp door to screen horizontally
                door.x = Math.max(0, Math.min(canvas.width - door.width, door.x));

                // Door falls off bottom = restart
                if (door.y > canvas.height + 100) {
                    restartLevel();
                }

                // Door squash/stretch recovery
                playableDoor.scaleX += (1 - playableDoor.scaleX) * 0.2;
                playableDoor.scaleY += (1 - playableDoor.scaleY) * 0.2;

                // Check if door touches player = win!
                const doorRect = { x: door.x, y: door.y, width: door.width, height: door.height };
                if (rectsCollide(player, doorRect)) {
                    levelComplete = true;
                }

                // Check door collision with spikes
                for (const trap of traps) {
                    if (trap.type === 'spikes' && trap.visible !== false) {
                        const spikeRect = { x: trap.x, y: trap.y, width: trap.width, height: trap.height };
                        if (rectsCollide(doorRect, spikeRect)) {
                            // Door dies!
                            playableDoor.dead = true;
                            playableDoor.deathTimer = 500;
                        }
                    }
                }
            } else if (playableDoor.active && playableDoor.dead) {
                // Playable door death animation
                playableDoor.deathTimer -= 16.67;
                if (playableDoor.deathTimer <= 0) {
                    restartLevel();
                }
                // Player stays still during door death
                player.vx = 0;
            } else {
                // Normal player movement
                // Horizontal movement - check for ice physics
                if (levelData.isIcy) {
                    // Ice physics - accelerate gradually, can't stop easily
                    const iceAccel = 0.3;
                    const iceFriction = 0.98;
                    const maxIceSpeed = CONFIG.MOVE_SPEED * 1.5;

                    if (effectiveLeft) {
                        player.vx -= iceAccel;
                        player.facingRight = false;
                    } else if (effectiveRight) {
                        player.vx += iceAccel;
                        player.facingRight = true;
                    }

                    // Apply friction (very little on ice)
                    player.vx *= iceFriction;

                    // Clamp speed
                    if (player.vx > maxIceSpeed) player.vx = maxIceSpeed;
                    if (player.vx < -maxIceSpeed) player.vx = -maxIceSpeed;
                } else {
                    // Normal movement
                    if (effectiveLeft) {
                        player.vx = -CONFIG.MOVE_SPEED;
                        player.facingRight = false;
                    } else if (effectiveRight) {
                        player.vx = CONFIG.MOVE_SPEED;
                        player.facingRight = true;
                    } else {
                        player.vx = 0;
                    }
                }

                // Jumping / Gravity Flip
                if (effectiveJump && player.onGround) {
                    if (levelData.gravityFlip) {
                        // Gravity flip level - flip gravity instead of jumping
                        player.gravityFlipped = !player.gravityFlipped;
                        player.onGround = false;
                        player.vy = player.gravityFlipped ? -5 : 5;  // Small push in new direction
                    } else {
                        // Normal jump
                        // Scale jump force with player size
                        player.vy = CONFIG.JUMP_FORCE * player.sizeScale;
                        player.onGround = false;
                        jumpCount++;  // Track jump count for jump-count platforms

                        // Grow on jump if level has this mechanic and growth not disabled
                        if (levelData.growOnJump && !player.growthDisabled) {
                            player.sizeScale *= 1.08;  // 8% bigger each jump
                            player.width = CONFIG.PLAYER_WIDTH * player.sizeScale;
                            player.height = CONFIG.PLAYER_HEIGHT * player.sizeScale;
                        }

                        // Apply jump stretch
                        player.scaleY = CONFIG.JUMP_STRETCH;
                        player.scaleX = 1 / CONFIG.JUMP_STRETCH;
                    }
                }
            }

            // Gravity - check for special level mechanics
            if (levelData.floatToCeiling && player.vy < 0) {
                // Keep going up at constant speed until hitting ceiling
                player.vy = -14;  // Fast upward velocity
            } else if (levelData.gravityFlip) {
                // Gravity flip level - gravity goes up or down depending on state
                const gravityDir = player.gravityFlipped ? -1 : 1;
                player.vy += CONFIG.GRAVITY * gravityDir;
                if (Math.abs(player.vy) > CONFIG.MAX_FALL_SPEED) {
                    player.vy = CONFIG.MAX_FALL_SPEED * gravityDir;
                }
            } else {
                player.vy += CONFIG.GRAVITY;
                if (player.vy > CONFIG.MAX_FALL_SPEED) {
                    player.vy = CONFIG.MAX_FALL_SPEED;
                }
            }

            // Apply velocity
            player.x += player.vx;
            player.y += player.vy;

            // Recover squash/stretch to normal
            player.scaleX += (1 - player.scaleX) * CONFIG.SQUASH_RECOVERY;
            player.scaleY += (1 - player.scaleY) * CONFIG.SQUASH_RECOVERY;

            // World bounds (left and right walls)
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) {
                player.x = canvas.width - player.width;
            }

            // Ceiling collision (for float-to-ceiling mechanic)
            if (player.y < 0) {
                player.y = 0;
                player.vy = 0;
            }

            // Check triggers before resolving collisions
            checkTriggers();

            // Update shadow (copycat level)
            if (shadow.active) {
                // Record current position with timestamp
                shadow.history.push({
                    x: player.x,
                    y: player.y,
                    time: Date.now()
                });

                // Find position from 'delay' milliseconds ago
                const targetTime = Date.now() - shadow.delay;
                let pastPosition = null;
                for (let i = shadow.history.length - 1; i >= 0; i--) {
                    if (shadow.history[i].time <= targetTime) {
                        pastPosition = shadow.history[i];
                        break;
                    }
                }

                if (pastPosition) {
                    shadow.x = pastPosition.x;
                    shadow.y = pastPosition.y;
                }

                // Clean up old history (keep only last 5 seconds)
                const cutoff = Date.now() - 5000;
                shadow.history = shadow.history.filter(h => h.time > cutoff);

                // Check collision between player and shadow
                const shadowRect = { x: shadow.x, y: shadow.y, width: player.width, height: player.height };
                if (rectsCollide(player, shadowRect) && shadow.history.length > shadow.delay / 16) {
                    killPlayer('crushed');
                }
            }

            // Update fake timer
            if (fakeTimer.active && !fakeTimer.revealed) {
                // Check if player is moving
                if (Math.abs(player.vx) > 0.1 || Math.abs(player.vy) > 0.5) {
                    fakeTimer.stillTime = 0;
                } else {
                    fakeTimer.stillTime += 16.67;
                }

                // If player has been still for 3 seconds, reveal it's fake
                if (fakeTimer.stillTime > 3000) {
                    fakeTimer.revealed = true;
                    // Show the real door
                    door.visible = true;
                }

                // Count down the timer (even though it's fake)
                fakeTimer.timeLeft -= 16.67;
                if (fakeTimer.timeLeft < 0) fakeTimer.timeLeft = 0;
            }

            // Track if player was airborne before collision resolution (for gravity flip on contact)
            const wasAirborne = !player.onGround;

            // Update traps
            updateTraps();

            // Update level expansion animation
            updateLevelExpansion();

            // Update player shrink animation
            updatePlayerShrink();

            // Update door animation
            updateDoorAnimation();

            // Update simple linear door slide
            if (doorSlide.active) {
                if (door.x < doorSlide.targetX) {
                    door.x += doorSlide.speed;
                    if (door.x >= doorSlide.targetX) {
                        door.x = doorSlide.targetX;
                        doorSlide.active = false;
                    }
                } else if (door.x > doorSlide.targetX) {
                    door.x -= doorSlide.speed;
                    if (door.x <= doorSlide.targetX) {
                        door.x = doorSlide.targetX;
                        doorSlide.active = false;
                    }
                }
            }

            // Resolve platform collisions
            resolveCollisions();

            // Gravity flip on contact (Level 23)
            if (LEVELS[currentLevel].gravityFlipOnContact) {
                // If player just landed (was airborne, now on ground), flip gravity
                if (wasAirborne && player.onGround) {
                    player.gravityFlipped = !player.gravityFlipped;
                    player.onGround = false;  // Force airborne again
                    player.vy = player.gravityFlipped ? -3 : 3;  // Small push in new direction
                }
            }

            // Check if fallen off screen (bottom normally, top if gravity flipped)
            // Don't kill during level expansion (player might be falling to a lower area)
            if (!levelExpansion.expanding && (player.y > canvas.height + 50 || player.y < -100)) {
                killPlayer('fallen');
                return;
            }

            // Check door collision (level complete) - only if door is visible
            if (door.visible !== false && rectsCollide(player, door)) {
                if (portalState.active && !portalState.teleporting) {
                    // Entering ground door - start teleport (can do multiple times)
                    portalState.teleporting = true;
                    portalState.teleportAnim = 0;
                    portalState.enteringDoor = 'ground';
                    player.vx = 0;
                    player.vy = 0;
                } else if (!portalState.active) {
                    levelComplete = true;
                }
            }

            // Portal level - check portal door collision
            if (portalState.active && portalState.teleported) {
                const portalDoor = traps.find(t => t.type === 'portalDoor');
                if (portalDoor) {
                    const portalRect = { x: portalDoor.x, y: portalDoor.y, width: portalDoor.width, height: portalDoor.height };
                    if (rectsCollide(player, portalRect)) {
                        if (portalState.exitedPortalDoor) {
                            // Re-entered portal door - win!
                            levelComplete = true;
                        }
                    } else {
                        // Player has exited the portal door area
                        portalState.exitedPortalDoor = true;
                    }
                }
            }
        }

        // ===========================================
        // RENDERING
        // ===========================================

        function render() {
            // Runner mode - completely different rendering
            if (LEVELS[currentLevel].isRunnerLevel && runner.active) {
                renderRunner();
                return;
            }

            // Clear canvas
            ctx.fillStyle = CONFIG.BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw platforms
            ctx.fillStyle = CONFIG.GROUND_COLOR;
            for (const platform of platforms) {
                if (platform.visible === false) continue;  // Skip hidden platforms
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
            }

            // Draw door (only if visible)
            if (door.visible !== false) {
                if (spikeControl.doorDead) {
                    // Draw door fragments flying
                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    for (const frag of spikeControl.doorFragments) {
                        ctx.save();
                        ctx.translate(frag.x, frag.y);
                        ctx.rotate(frag.rotation);
                        ctx.globalAlpha = Math.max(0, 1 - spikeControl.doorDeathAnim);
                        ctx.fillRect(-frag.size/2, -frag.size/2, frag.size, frag.size);
                        ctx.restore();
                    }
                    ctx.globalAlpha = 1;
                } else if (playableDoor.dead) {
                    // Draw dying door (flashing red)
                    ctx.fillStyle = Math.floor(playableDoor.deathTimer / 50) % 2 === 0 ? '#ff0000' : CONFIG.DOOR_COLOR;
                    ctx.fillRect(door.x, door.y, door.width, door.height);
                } else if (playableDoor.active) {
                    // Draw playable door with deformation (like player)
                    ctx.save();
                    const centerX = door.x + door.width / 2;
                    const centerY = door.y + door.height / 2;
                    ctx.translate(centerX, centerY);
                    ctx.scale(playableDoor.scaleX, playableDoor.scaleY);
                    ctx.translate(-centerX, -centerY);

                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    ctx.fillRect(door.x, door.y, door.width, door.height);

                    // Door handle
                    ctx.fillStyle = '#3a9a5a';
                    ctx.beginPath();
                    ctx.arc(door.x + 32, door.y + 35, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Eyes on playable door to show it's alive!
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(door.x + 12, door.y + 20, 6, 0, Math.PI * 2);
                    ctx.arc(door.x + 28, door.y + 20, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(door.x + 12 + (playableDoor.facingRight ? 2 : -2), door.y + 20, 3, 0, Math.PI * 2);
                    ctx.arc(door.x + 28 + (playableDoor.facingRight ? 2 : -2), door.y + 20, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                } else {
                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    ctx.fillRect(door.x, door.y, door.width, door.height);
                    // Door handle
                    ctx.fillStyle = '#3a9a5a';
                    ctx.beginPath();
                    ctx.arc(door.x + 32, door.y + 35, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw traps
            for (const trap of traps) {
                // Skip hidden traps
                if (trap.visible === false) continue;

                // Streetlamp - draws pole, lamp head, and light cone
                if (trap.type === 'streetlamp') {
                    const lampX = trap.x;
                    const lampY = trap.y;
                    const groundY = 400;  // Ground level

                    // Draw light cone first (behind everything)
                    ctx.save();
                    const gradient = ctx.createRadialGradient(
                        lampX, lampY + 20, 5,
                        lampX, groundY - 20, trap.lightRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 255, 200, 0.4)');
                    gradient.addColorStop(0.5, 'rgba(255, 255, 180, 0.2)');
                    gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');

                    // Draw cone shape
                    ctx.beginPath();
                    ctx.moveTo(lampX - trap.lightConeTop, lampY + 30);
                    ctx.lineTo(lampX - trap.lightRadius, groundY);
                    ctx.lineTo(lampX + trap.lightRadius, groundY);
                    ctx.lineTo(lampX + trap.lightConeTop, lampY + 30);
                    ctx.closePath();
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    ctx.restore();

                    // Draw lamp pole
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(lampX - 4, lampY, 8, groundY - lampY);

                    // Draw lamp head (decorative)
                    ctx.fillStyle = '#444444';
                    ctx.fillRect(lampX - 15, lampY - 5, 30, 10);
                    ctx.fillRect(lampX - 12, lampY + 5, 24, 15);

                    // Draw bulb glow
                    ctx.fillStyle = '#ffffaa';
                    ctx.beginPath();
                    ctx.arc(lampX, lampY + 20, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Bulb highlight
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(lampX - 2, lampY + 18, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Melting door - looks like a normal door but melts when touched
                if (trap.type === 'meltingDoor' && !trap.melted) {
                    ctx.save();

                    if (trap.melting) {
                        // Melting animation - door drips and shrinks
                        const melt = trap.meltProgress;

                        // Wobble effect
                        ctx.translate(trap.x + trap.width/2, trap.y);
                        ctx.scale(1 - melt * 0.3, 1 - melt * 0.8);
                        ctx.translate(-(trap.x + trap.width/2), -trap.y);

                        // Color shifts to orange/red as it melts
                        const r = Math.floor(80 + melt * 175);
                        const g = Math.floor(200 - melt * 120);
                        const b = Math.floor(120 - melt * 80);
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;

                        // Draw melting drips
                        for (let i = 0; i < 5; i++) {
                            const dripX = trap.x + (trap.width / 5) * i + 5;
                            const dripLen = melt * 40 * (0.5 + Math.random() * 0.5);
                            ctx.fillRect(dripX, trap.y + trap.height, 6, dripLen);
                        }
                    } else {
                        // Normal door appearance (matches real door exactly)
                        ctx.fillStyle = CONFIG.DOOR_COLOR;
                    }

                    // Door body
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Door handle (only if not too melted)
                    if (!trap.melting || trap.meltProgress < 0.7) {
                        ctx.fillStyle = trap.melting ? '#8B4513' : '#3a9a5a';
                        ctx.beginPath();
                        ctx.arc(trap.x + 32, trap.y + 35, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.restore();
                }

                // Killer door - looks exactly like a normal door (that's the trap!)
                if (trap.type === 'killerDoor') {
                    if (trap.triggered) {
                        // Door flying away
                        if (!trap.doorGone) {
                            ctx.save();
                            ctx.translate(trap.doorFlyX + 20, trap.doorFlyY + 30);
                            ctx.rotate(trap.doorRotation);
                            ctx.fillStyle = CONFIG.DOOR_COLOR;
                            ctx.fillRect(-20, -30, 40, 60);
                            ctx.fillStyle = '#3a9a5a';
                            ctx.beginPath();
                            ctx.arc(12, 5, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }

                        // Ceiling spikes descending
                        ctx.fillStyle = '#ff4444';
                        const spikeWidth = 40;
                        const numSpikes = Math.ceil(800 / spikeWidth);
                        for (let i = 0; i < numSpikes; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * spikeWidth, trap.spikeY - 50);
                            ctx.lineTo(i * spikeWidth + spikeWidth / 2, trap.spikeY);
                            ctx.lineTo((i + 1) * spikeWidth, trap.spikeY - 50);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Spike base bar
                        ctx.fillStyle = '#aa0000';
                        ctx.fillRect(0, trap.spikeY - 60, 800, 15);

                        // Menacing shading on spikes
                        ctx.fillStyle = '#cc6666';
                        for (let i = 0; i < numSpikes; i++) {
                            ctx.beginPath();
                            ctx.moveTo(i * spikeWidth + 5, trap.spikeY - 48);
                            ctx.lineTo(i * spikeWidth + spikeWidth / 2, trap.spikeY - 5);
                            ctx.lineTo(i * spikeWidth + spikeWidth / 2 - 5, trap.spikeY - 10);
                            ctx.lineTo(i * spikeWidth + 8, trap.spikeY - 45);
                            ctx.closePath();
                            ctx.fill();
                        }

                    } else {
                        // Normal door appearance
                        ctx.fillStyle = CONFIG.DOOR_COLOR;
                        ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                        // Door handle
                        ctx.fillStyle = '#3a9a5a';
                        ctx.beginPath();
                        ctx.arc(trap.x + 32, trap.y + 35, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Flying fake door - appears then flies away
                if (trap.type === 'flyingFakeDoor' && !trap.gone) {
                    ctx.save();

                    if (trap.flying) {
                        // Shake and spin as it flies
                        const shake = Math.sin(trap.flyProgress * 30) * 5;
                        ctx.translate(trap.x + trap.width/2 + shake, trap.y + trap.height/2);
                        ctx.rotate(trap.flyProgress * 2);
                        ctx.translate(-(trap.x + trap.width/2), -(trap.y + trap.height/2));
                    }

                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                    // Door handle
                    ctx.fillStyle = '#3a9a5a';
                    ctx.beginPath();
                    ctx.arc(trap.x + 32, trap.y + 35, 4, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Transforming spikes - spikes that become a door
                if (trap.type === 'transformingSpikes' && !trap.transformed) {
                    ctx.save();

                    if (trap.transforming) {
                        const t = trap.transformProgress;

                        // Phase 1 (0-0.3): Spikes glow and pulse
                        if (t < 0.3) {
                            const glowIntensity = Math.sin(t * 30) * 0.5 + 0.5;
                            ctx.shadowColor = '#ffff00';
                            ctx.shadowBlur = 20 + glowIntensity * 20;

                            // Draw glowing spikes
                            ctx.fillStyle = `rgb(255, ${100 + glowIntensity * 100}, ${glowIntensity * 100})`;
                            const spikeCount = Math.floor(trap.width / 20);
                            const spikeWidth = trap.width / spikeCount;
                            for (let i = 0; i < spikeCount; i++) {
                                ctx.beginPath();
                                ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                                ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                                ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                                ctx.closePath();
                                ctx.fill();
                            }
                        }
                        // Phase 2 (0.3-0.6): Spikes melt down, particles swirl
                        else if (t < 0.6) {
                            const meltT = (t - 0.3) / 0.3;
                            ctx.shadowColor = '#00ff00';
                            ctx.shadowBlur = 15;

                            // Melting blob
                            ctx.fillStyle = `rgb(${80 + meltT * 50}, ${150 + meltT * 50}, ${100 + meltT * 50})`;
                            const blobHeight = trap.height * (1 - meltT * 0.7);
                            ctx.fillRect(trap.x, trap.y + trap.height - blobHeight, trap.width, blobHeight);

                            // Swirling particles
                            ctx.fillStyle = '#50c878';
                            for (let i = 0; i < 12; i++) {
                                const angle = (i / 12) * Math.PI * 2 + t * 10;
                                const radius = 30 + Math.sin(t * 20 + i) * 15;
                                const px = trap.x + trap.width/2 + Math.cos(angle) * radius;
                                const py = trap.y + trap.height/2 + Math.sin(angle) * radius * 0.5;
                                ctx.beginPath();
                                ctx.arc(px, py, 3 + Math.random() * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        // Phase 3 (0.6-1.0): Door rises up from the blob
                        else {
                            const riseT = (t - 0.6) / 0.4;
                            ctx.shadowColor = '#50c878';
                            ctx.shadowBlur = 25 * (1 - riseT);

                            // Growing door
                            const doorHeight = 60 * riseT;
                            const doorY = trap.y + trap.height - doorHeight;
                            ctx.fillStyle = CONFIG.DOOR_COLOR;
                            ctx.fillRect(trap.x + (trap.width - 40)/2, doorY, 40, doorHeight);

                            // Door handle appears near the end
                            if (riseT > 0.7) {
                                ctx.fillStyle = '#3a9a5a';
                                ctx.beginPath();
                                ctx.arc(trap.x + (trap.width - 40)/2 + 32, doorY + 35, 4 * ((riseT - 0.7) / 0.3), 0, Math.PI * 2);
                                ctx.fill();
                            }

                            // Sparkles around the new door
                            ctx.fillStyle = '#aaffaa';
                            for (let i = 0; i < 8; i++) {
                                const sparkleX = trap.x + trap.width/2 + (Math.random() - 0.5) * 60;
                                const sparkleY = doorY + Math.random() * doorHeight;
                                ctx.beginPath();
                                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    } else {
                        // Normal spikes appearance
                        ctx.fillStyle = '#ff4444';
                        const spikeCount = Math.floor(trap.width / 20);
                        const spikeWidth = trap.width / spikeCount;
                        for (let i = 0; i < spikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                            ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                            ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }

                    ctx.shadowBlur = 0;
                    ctx.restore();
                }

                // Boss - EPIC EVIL DEMON LORD WITH LEGS
                if (trap.type === 'boss' && !trap.defeated) {
                    ctx.save();

                    const bossX = trap.state === 'burrowed' ? trap.headX : trap.x;
                    const time = Date.now() / 1000;  // For animations

                    // Boss anatomy: head (60) + torso (80) + legs (60) = 200 total
                    const headH = 60;
                    const torsoH = 80;
                    const legH = 60;
                    const bossW = 100;

                    // Calculate how much is visible based on burrow state
                    let burrowAmount = 0;  // 0 = fully visible, 1 = only head
                    if (trap.state === 'burrowing' || trap.state === 'emerging') {
                        burrowAmount = trap.burrowProgress;
                    } else if (trap.state === 'burrowed') {
                        burrowAmount = 1;
                    }

                    // Death animation
                    if (trap.state === 'dying') {
                        ctx.globalAlpha = 1 - trap.deathProgress;
                        const shake = Math.sin(trap.deathProgress * 50) * 15;
                        ctx.translate(shake, 0);
                    }

                    // Evil aura/glow effect
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 25 + Math.sin(time * 3) * 10;

                    const groundY = trap.y + trap.height;  // Where feet touch ground
                    const headX = trap.state === 'burrowed' ? trap.headX : bossX;

                    // Calculate Y positions (legs sink into ground when burrowing)
                    const legSink = burrowAmount * (legH + torsoH);  // How much legs have sunk
                    const feetY = groundY + legSink;
                    const torsoBottomY = feetY - legH;
                    const torsoTopY = torsoBottomY - torsoH;
                    const headTopY = torsoTopY - headH;

                    // Walking animation for legs
                    const walkCycle = Math.sin(time * 8) * (trap.state === 'burrowed' ? 0.3 : 0);

                    // Draw LEGS (only if not fully burrowed)
                    if (burrowAmount < 0.9) {
                        ctx.fillStyle = '#1a0000';

                        // Left leg
                        const leftLegAngle = walkCycle * 0.2;
                        ctx.save();
                        ctx.translate(bossX - 20, torsoBottomY);
                        ctx.rotate(leftLegAngle);

                        // Thigh
                        ctx.fillStyle = '#220000';
                        ctx.fillRect(-15, 0, 30, legH * 0.5);

                        // Knee armor
                        ctx.fillStyle = '#440000';
                        ctx.beginPath();
                        ctx.arc(0, legH * 0.5, 12, 0, Math.PI * 2);
                        ctx.fill();

                        // Shin
                        ctx.fillStyle = '#220000';
                        ctx.fillRect(-12, legH * 0.5, 24, legH * 0.5);

                        // Foot - clawed
                        ctx.fillStyle = '#1a0000';
                        ctx.beginPath();
                        ctx.moveTo(-15, legH);
                        ctx.lineTo(-25, legH + 10);
                        ctx.lineTo(20, legH + 10);
                        ctx.lineTo(15, legH);
                        ctx.fill();
                        // Toe claws
                        ctx.fillStyle = '#111';
                        for (let c = 0; c < 3; c++) {
                            ctx.beginPath();
                            ctx.moveTo(-18 + c * 15, legH + 10);
                            ctx.lineTo(-15 + c * 15, legH + 20);
                            ctx.lineTo(-12 + c * 15, legH + 10);
                            ctx.fill();
                        }
                        ctx.restore();

                        // Right leg
                        const rightLegAngle = -walkCycle * 0.2;
                        ctx.save();
                        ctx.translate(bossX + 20, torsoBottomY);
                        ctx.rotate(rightLegAngle);

                        ctx.fillStyle = '#220000';
                        ctx.fillRect(-15, 0, 30, legH * 0.5);
                        ctx.fillStyle = '#440000';
                        ctx.beginPath();
                        ctx.arc(0, legH * 0.5, 12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#220000';
                        ctx.fillRect(-12, legH * 0.5, 24, legH * 0.5);
                        ctx.fillStyle = '#1a0000';
                        ctx.beginPath();
                        ctx.moveTo(-15, legH);
                        ctx.lineTo(-25, legH + 10);
                        ctx.lineTo(20, legH + 10);
                        ctx.lineTo(15, legH);
                        ctx.fill();
                        ctx.fillStyle = '#111';
                        for (let c = 0; c < 3; c++) {
                            ctx.beginPath();
                            ctx.moveTo(-18 + c * 15, legH + 10);
                            ctx.lineTo(-15 + c * 15, legH + 20);
                            ctx.lineTo(-12 + c * 15, legH + 10);
                            ctx.fill();
                        }
                        ctx.restore();
                    }

                    // Draw TORSO (only if not fully burrowed)
                    if (burrowAmount < 0.7) {
                        // Dark demonic torso with gradient
                        const torsoGrad = ctx.createLinearGradient(bossX - bossW/2, torsoTopY, bossX + bossW/2, torsoBottomY);
                        torsoGrad.addColorStop(0, '#1a0000');
                        torsoGrad.addColorStop(0.5, '#330000');
                        torsoGrad.addColorStop(1, '#220000');
                        ctx.fillStyle = torsoGrad;

                        // Torso shape - broader at shoulders
                        ctx.beginPath();
                        ctx.moveTo(bossX - 35, torsoBottomY);
                        ctx.lineTo(bossX - 50, torsoTopY + 20);
                        ctx.lineTo(bossX - 45, torsoTopY);
                        ctx.lineTo(bossX + 45, torsoTopY);
                        ctx.lineTo(bossX + 50, torsoTopY + 20);
                        ctx.lineTo(bossX + 35, torsoBottomY);
                        ctx.closePath();
                        ctx.fill();

                        // Armored chest plates
                        ctx.fillStyle = '#440000';
                        ctx.fillRect(bossX - 40, torsoTopY + 15, 80, 12);
                        ctx.fillRect(bossX - 35, torsoTopY + 35, 70, 10);

                        // Shoulder spikes
                        ctx.fillStyle = '#220000';
                        for (let i = 0; i < 3; i++) {
                            // Left spikes
                            ctx.beginPath();
                            ctx.moveTo(bossX - 50, torsoTopY + 10 + i * 12);
                            ctx.lineTo(bossX - 70 - i * 5, torsoTopY + 5 + i * 12);
                            ctx.lineTo(bossX - 50, torsoTopY + 20 + i * 12);
                            ctx.fill();
                            // Right spikes
                            ctx.beginPath();
                            ctx.moveTo(bossX + 50, torsoTopY + 10 + i * 12);
                            ctx.lineTo(bossX + 70 + i * 5, torsoTopY + 5 + i * 12);
                            ctx.lineTo(bossX + 50, torsoTopY + 20 + i * 12);
                            ctx.fill();
                        }

                        // Glowing chest rune/core
                        ctx.shadowColor = '#ff4400';
                        ctx.shadowBlur = 20;
                        ctx.fillStyle = '#ff2200';
                        const coreY = torsoTopY + torsoH/2;
                        ctx.beginPath();
                        ctx.moveTo(bossX, coreY - 18);
                        ctx.lineTo(bossX - 15, coreY);
                        ctx.lineTo(bossX, coreY + 18);
                        ctx.lineTo(bossX + 15, coreY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.moveTo(bossX, coreY - 10);
                        ctx.lineTo(bossX - 8, coreY);
                        ctx.lineTo(bossX, coreY + 10);
                        ctx.lineTo(bossX + 8, coreY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ff0000';
                    }

                    // Draw HEAD (always visible)
                    const headY = trap.state === 'burrowed' ? groundY - 50 : headTopY;

                    // Head base - menacing shape
                    ctx.fillStyle = '#2a0000';
                    ctx.beginPath();
                    ctx.moveTo(headX - 40, headY + headH);
                    ctx.lineTo(headX - 45, headY + 25);
                    ctx.lineTo(headX - 35, headY + 5);
                    ctx.lineTo(headX + 35, headY + 5);
                    ctx.lineTo(headX + 45, headY + 25);
                    ctx.lineTo(headX + 40, headY + headH);
                    ctx.closePath();
                    ctx.fill();

                    // MASSIVE HORNS
                    ctx.fillStyle = '#1a0000';
                    ctx.beginPath();
                    ctx.moveTo(headX - 30, headY + 10);
                    ctx.lineTo(headX - 55, headY - 45);
                    ctx.lineTo(headX - 45, headY - 40);
                    ctx.lineTo(headX - 25, headY + 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(headX + 30, headY + 10);
                    ctx.lineTo(headX + 55, headY - 45);
                    ctx.lineTo(headX + 45, headY - 40);
                    ctx.lineTo(headX + 25, headY + 5);
                    ctx.closePath();
                    ctx.fill();
                    // Horn highlights
                    ctx.fillStyle = '#3a0505';
                    ctx.beginPath();
                    ctx.moveTo(headX - 32, headY + 5);
                    ctx.lineTo(headX - 50, headY - 35);
                    ctx.lineTo(headX - 45, headY - 32);
                    ctx.lineTo(headX - 28, headY + 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(headX + 32, headY + 5);
                    ctx.lineTo(headX + 50, headY - 35);
                    ctx.lineTo(headX + 45, headY - 32);
                    ctx.lineTo(headX + 28, headY + 8);
                    ctx.closePath();
                    ctx.fill();

                    // GLOWING DEMONIC EYES
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.ellipse(headX - 18, headY + 25, 14, 10, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(headX + 18, headY + 25, 14, 10, 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    const eyePulse = 0.7 + Math.sin(time * 5) * 0.3;
                    ctx.fillStyle = `rgba(255, 0, 0, ${eyePulse})`;
                    ctx.beginPath();
                    ctx.ellipse(headX - 18, headY + 25, 11, 7, -0.2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(headX + 18, headY + 25, 11, 7, 0.2, 0, Math.PI * 2);
                    ctx.fill();

                    const pupilOffsetX = Math.sign(player.x - headX) * 3;
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(headX - 18 + pupilOffsetX, headY + 25, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(headX + 18 + pupilOffsetX, headY + 25, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Angry brow ridge
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#1a0000';
                    ctx.beginPath();
                    ctx.moveTo(headX - 35, headY + 18);
                    ctx.lineTo(headX - 5, headY + 12);
                    ctx.lineTo(headX - 5, headY + 18);
                    ctx.lineTo(headX - 32, headY + 24);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(headX + 35, headY + 18);
                    ctx.lineTo(headX + 5, headY + 12);
                    ctx.lineTo(headX + 5, headY + 18);
                    ctx.lineTo(headX + 32, headY + 24);
                    ctx.fill();

                    // TERRIFYING MOUTH
                    ctx.fillStyle = '#000000';
                    const mouthOpen = trap.state === 'standing' ? 8 + Math.sin(time * 4) * 4 : 5;
                    ctx.beginPath();
                    ctx.moveTo(headX - 25, headY + 42);
                    ctx.quadraticCurveTo(headX, headY + 42 + mouthOpen, headX + 25, headY + 42);
                    ctx.quadraticCurveTo(headX, headY + 52 + mouthOpen, headX - 25, headY + 42);
                    ctx.fill();

                    // Razor sharp teeth
                    ctx.fillStyle = '#ffffff';
                    for (let i = 0; i < 7; i++) {
                        const toothX = headX - 21 + i * 7;
                        ctx.beginPath();
                        ctx.moveTo(toothX, headY + 42);
                        ctx.lineTo(toothX + 3.5, headY + 50 + (i % 2) * 3);
                        ctx.lineTo(toothX + 7, headY + 42);
                        ctx.fill();
                    }

                    // Dripping blood
                    ctx.fillStyle = '#880000';
                    const dripOffset = (time * 50) % 30;
                    ctx.beginPath();
                    ctx.ellipse(headX - 15, headY + 55 + dripOffset, 3, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(headX + 10, headY + 52 + (dripOffset + 15) % 30, 2, 4, 0, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();

                    // Draw fireballs
                    for (const fb of trap.fireballs) {
                        const goingRight = fb.vx > 0;

                        // Fireball body
                        ctx.fillStyle = '#FF4500';
                        ctx.beginPath();
                        ctx.ellipse(fb.x, fb.y, fb.width/2, fb.height/2, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Fireball inner glow
                        ctx.fillStyle = '#FFD700';
                        ctx.beginPath();
                        ctx.ellipse(fb.x + (goingRight ? -5 : 5), fb.y, fb.width/3, fb.height/3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Flame trail (behind the fireball)
                        ctx.fillStyle = '#FF6600';
                        ctx.beginPath();
                        if (goingRight) {
                            ctx.moveTo(fb.x - fb.width/2, fb.y - 5);
                            ctx.lineTo(fb.x - fb.width/2 - 20, fb.y);
                            ctx.lineTo(fb.x - fb.width/2, fb.y + 5);
                        } else {
                            ctx.moveTo(fb.x + fb.width/2, fb.y - 5);
                            ctx.lineTo(fb.x + fb.width/2 + 20, fb.y);
                            ctx.lineTo(fb.x + fb.width/2, fb.y + 5);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Health indicator (moved up higher)
                    if (trap.health > 0) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(trap.x - 45, trap.y - 50, 90, 12);
                        ctx.fillStyle = '#00FF00';
                        ctx.fillRect(trap.x - 43, trap.y - 48, (86 * trap.health / 3), 8);
                    }
                }

                if (trap.type === 'fallingBlock' && (trap.active || trap.landed)) {
                    ctx.fillStyle = CONFIG.TRAP_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Add some detail to the block
                    ctx.fillStyle = '#cc5555';
                    ctx.fillRect(trap.x + 5, trap.y + 5, trap.width - 10, 3);
                    ctx.fillRect(trap.x + 5, trap.y + trap.height - 8, trap.width - 10, 3);

                    // Draw side spikes if enabled
                    if (trap.hasSideSpikes) {
                        ctx.fillStyle = '#ff4444';
                        const spikeCount = Math.floor((trap.height - 20) / 20);
                        const spikeHeight = (trap.height - 20) / spikeCount;

                        // Left side spikes
                        for (let i = 0; i < spikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(trap.x, trap.y + 10 + i * spikeHeight);
                            ctx.lineTo(trap.x - 12, trap.y + 10 + i * spikeHeight + spikeHeight / 2);
                            ctx.lineTo(trap.x, trap.y + 10 + (i + 1) * spikeHeight);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Right side spikes
                        for (let i = 0; i < spikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(trap.x + trap.width, trap.y + 10 + i * spikeHeight);
                            ctx.lineTo(trap.x + trap.width + 12, trap.y + 10 + i * spikeHeight + spikeHeight / 2);
                            ctx.lineTo(trap.x + trap.width, trap.y + 10 + (i + 1) * spikeHeight);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Spike shine
                        ctx.fillStyle = '#ff8888';
                        for (let i = 0; i < spikeCount; i++) {
                            // Left shine
                            ctx.beginPath();
                            ctx.moveTo(trap.x - 2, trap.y + 10 + i * spikeHeight + spikeHeight * 0.3);
                            ctx.lineTo(trap.x - 9, trap.y + 10 + i * spikeHeight + spikeHeight / 2);
                            ctx.lineTo(trap.x - 2, trap.y + 10 + i * spikeHeight + spikeHeight * 0.5);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }

                    // Draw top spikes if enabled
                    if (trap.hasTopSpikes) {
                        ctx.fillStyle = '#ff4444';
                        const topSpikeCount = Math.floor(trap.width / 20);
                        const topSpikeWidth = trap.width / topSpikeCount;

                        for (let i = 0; i < topSpikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(trap.x + i * topSpikeWidth, trap.y);
                            ctx.lineTo(trap.x + i * topSpikeWidth + topSpikeWidth / 2, trap.y - 18);
                            ctx.lineTo(trap.x + (i + 1) * topSpikeWidth, trap.y);
                            ctx.closePath();
                            ctx.fill();
                        }

                        // Top spike shine
                        ctx.fillStyle = '#ff8888';
                        for (let i = 0; i < topSpikeCount; i++) {
                            ctx.beginPath();
                            ctx.moveTo(trap.x + i * topSpikeWidth + topSpikeWidth * 0.3, trap.y - 2);
                            ctx.lineTo(trap.x + i * topSpikeWidth + topSpikeWidth / 2, trap.y - 15);
                            ctx.lineTo(trap.x + i * topSpikeWidth + topSpikeWidth * 0.5, trap.y - 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                }

                if (trap.type === 'collapsingPlatform' && !trap.fallen) {
                    // Shake effect when activated
                    const shakeX = trap.shaking ? (Math.random() - 0.5) * 6 : 0;

                    // Color changes when activated (warning!)
                    if (trap.shaking) {
                        ctx.fillStyle = '#d4a574';  // Warning orange-ish
                    } else {
                        ctx.fillStyle = CONFIG.GROUND_COLOR;  // Looks like normal ground
                    }

                    ctx.fillRect(trap.x + shakeX, trap.y, trap.width, trap.height);

                    // Add crack lines when shaking
                    if (trap.shaking) {
                        ctx.strokeStyle = '#8b6914';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(trap.x + shakeX + trap.width * 0.3, trap.y);
                        ctx.lineTo(trap.x + shakeX + trap.width * 0.4, trap.y + trap.height);
                        ctx.moveTo(trap.x + shakeX + trap.width * 0.7, trap.y);
                        ctx.lineTo(trap.x + shakeX + trap.width * 0.6, trap.y + trap.height);
                        ctx.stroke();
                    }
                }

                if (trap.type === 'vanishingPlatform') {
                    if (!trap.vanished) {
                        // Draw solid platform (looks like normal ground)
                        ctx.fillStyle = CONFIG.GROUND_COLOR;
                        ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                    } else {
                        // Draw ghost outline when vanished
                        ctx.strokeStyle = 'rgba(232, 232, 232, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);
                        ctx.setLineDash([]);
                    }
                }

                if (trap.type === 'flyingDoor' && !trap.platformGone) {
                    // Draw the platform under the door
                    ctx.fillStyle = CONFIG.GROUND_COLOR;
                    ctx.fillRect(trap.platformX, trap.platformY, trap.platformWidth, trap.platformHeight);
                }

                if (trap.type === 'spikeWall' && (trap.rising || trap.risen || trap.disappearing) && !trap.gone) {
                    // Draw the wall body
                    ctx.fillStyle = CONFIG.TRAP_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Draw darker stripes on wall
                    ctx.fillStyle = '#cc5555';
                    for (let i = 0; i < 3; i++) {
                        ctx.fillRect(trap.x + 5, trap.y + 15 + i * 25, trap.width - 10, 3);
                    }

                    // Draw spikes on top
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = 4;
                    const spikeWidth = trap.width / spikeCount;
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y - trap.spikeHeight);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Draw spikes on left side
                    const sideSpikeCount = 4;
                    const sideSpikeHeight = (trap.height - 20) / sideSpikeCount;
                    for (let i = 0; i < sideSpikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x, trap.y + 10 + i * sideSpikeHeight);
                        ctx.lineTo(trap.x - 12, trap.y + 10 + i * sideSpikeHeight + sideSpikeHeight / 2);
                        ctx.lineTo(trap.x, trap.y + 10 + (i + 1) * sideSpikeHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Draw spikes on right side
                    for (let i = 0; i < sideSpikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + trap.width, trap.y + 10 + i * sideSpikeHeight);
                        ctx.lineTo(trap.x + trap.width + 12, trap.y + 10 + i * sideSpikeHeight + sideSpikeHeight / 2);
                        ctx.lineTo(trap.x + trap.width, trap.y + 10 + (i + 1) * sideSpikeHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Add menacing shine to top spikes
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y - 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y - trap.spikeHeight + 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y - 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw shrink button
                if (trap.type === 'shrinkButton' && trap.visible) {
                    // Button base
                    ctx.fillStyle = trap.activated ? '#666666' : '#ffcc00';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button top (3D effect)
                    ctx.fillStyle = trap.activated ? '#888888' : '#ffee55';
                    ctx.fillRect(trap.x + 3, trap.y + 2, trap.width - 6, trap.height - 6);

                    // Shrink icon (arrows pointing inward)
                    if (!trap.activated) {
                        ctx.strokeStyle = '#996600';
                        ctx.lineWidth = 2;
                        const cx = trap.x + trap.width / 2;
                        const cy = trap.y + trap.height / 2;

                        // Left arrow
                        ctx.beginPath();
                        ctx.moveTo(cx - 12, cy);
                        ctx.lineTo(cx - 5, cy);
                        ctx.moveTo(cx - 8, cy - 3);
                        ctx.lineTo(cx - 5, cy);
                        ctx.lineTo(cx - 8, cy + 3);
                        ctx.stroke();

                        // Right arrow
                        ctx.beginPath();
                        ctx.moveTo(cx + 12, cy);
                        ctx.lineTo(cx + 5, cy);
                        ctx.moveTo(cx + 8, cy - 3);
                        ctx.lineTo(cx + 5, cy);
                        ctx.lineTo(cx + 8, cy + 3);
                        ctx.stroke();
                    }

                    // Sparkle effect when appearing
                    if (!trap.activated && Math.random() < 0.1) {
                        ctx.fillStyle = 'rgba(255, 255, 200, 0.8)';
                        const sparkleX = trap.x + Math.random() * trap.width;
                        const sparkleY = trap.y + Math.random() * trap.height;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw size reset button
                if (trap.type === 'sizeResetButton' && trap.visible) {
                    // Button base - cyan/blue color
                    ctx.fillStyle = trap.activated ? '#666666' : '#44aacc';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button top (3D effect)
                    ctx.fillStyle = trap.activated ? '#888888' : '#66ccee';
                    ctx.fillRect(trap.x + 3, trap.y + 2, trap.width - 6, trap.height - 6);

                    // Reset icon (circular arrow) when not activated
                    if (!trap.activated) {
                        ctx.strokeStyle = '#226688';
                        ctx.lineWidth = 2;
                        const cx = trap.x + trap.width / 2;
                        const cy = trap.y + trap.height / 2;

                        // Draw circular arrow
                        ctx.beginPath();
                        ctx.arc(cx, cy, 8, 0.5, 2 * Math.PI - 0.5);
                        ctx.stroke();

                        // Arrow head
                        ctx.beginPath();
                        ctx.moveTo(cx + 6, cy - 6);
                        ctx.lineTo(cx + 8, cy - 1);
                        ctx.lineTo(cx + 3, cy - 3);
                        ctx.stroke();
                    }
                }

                // Draw door control button
                if (trap.type === 'doorControlButton' && trap.visible) {
                    // Button base - green color to indicate door control
                    ctx.fillStyle = trap.activated ? '#666666' : '#44cc88';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button top (3D effect)
                    ctx.fillStyle = trap.activated ? '#888888' : '#66eebb';
                    ctx.fillRect(trap.x + 3, trap.y + 2, trap.width - 6, trap.height - 6);

                    // Door icon when not activated
                    if (!trap.activated) {
                        ctx.fillStyle = '#228855';
                        const iconX = trap.x + trap.width / 2 - 6;
                        const iconY = trap.y + 3;
                        ctx.fillRect(iconX, iconY, 12, 10);
                        // Door handle
                        ctx.fillStyle = '#115533';
                        ctx.beginPath();
                        ctx.arc(iconX + 9, iconY + 6, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Sparkle effect
                    if (!trap.activated && Math.random() < 0.1) {
                        ctx.fillStyle = 'rgba(200, 255, 220, 0.8)';
                        const sparkleX = trap.x + Math.random() * trap.width;
                        const sparkleY = trap.y + Math.random() * trap.height;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw playable door button (purple - indicates door becomes a player)
                if (trap.type === 'playableDoorButton' && trap.visible) {
                    // Button base - purple color
                    ctx.fillStyle = trap.activated ? '#666666' : '#8844cc';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button top (3D effect)
                    ctx.fillStyle = trap.activated ? '#888888' : '#aa66ee';
                    ctx.fillRect(trap.x + 3, trap.y + 2, trap.width - 6, trap.height - 6);

                    // Door with legs icon when not activated
                    if (!trap.activated) {
                        ctx.fillStyle = '#553388';
                        const iconX = trap.x + trap.width / 2 - 6;
                        const iconY = trap.y + 2;
                        ctx.fillRect(iconX, iconY, 12, 8);
                        // Little legs under door
                        ctx.fillRect(iconX + 1, iconY + 8, 3, 4);
                        ctx.fillRect(iconX + 8, iconY + 8, 3, 4);
                    }

                    // Sparkle effect
                    if (!trap.activated && Math.random() < 0.15) {
                        ctx.fillStyle = 'rgba(200, 180, 255, 0.8)';
                        const sparkleX = trap.x + Math.random() * trap.width;
                        const sparkleY = trap.y + Math.random() * trap.height;
                        ctx.beginPath();
                        ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Draw wall spikes (spikes pointing right from left wall)
                if (trap.type === 'wallSpikes') {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.height / 25);
                    const spikeHeight = trap.height / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x, trap.y + i * spikeHeight);
                        ctx.lineTo(trap.x + trap.width, trap.y + i * spikeHeight + spikeHeight / 2);
                        ctx.lineTo(trap.x, trap.y + (i + 1) * spikeHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + 2, trap.y + i * spikeHeight + spikeHeight * 0.3);
                        ctx.lineTo(trap.x + trap.width - 3, trap.y + i * spikeHeight + spikeHeight / 2);
                        ctx.lineTo(trap.x + 2, trap.y + i * spikeHeight + spikeHeight * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw floor spikes (spikes pointing up from ground)
                // Draw basic spikes (pointing up from floor)
                if (trap.type === 'spikes') {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.max(1, Math.floor(trap.width / 20));
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + trap.height - 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + trap.height - 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw door jump trigger spikes (appear when door jumps in zone, disappear after delay)
                if (trap.type === 'doorJumpTriggerSpikes' && trap.visible) {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.max(1, Math.floor(trap.width / 20));
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + trap.height - 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + trap.height - 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                if (trap.type === 'floorSpikes') {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.width / 20);
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + trap.height - 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + trap.height - 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw launch block (looks exactly like regular falling blocks - no visual difference!)
                if (trap.type === 'launchBlock' && (trap.active || trap.landed || trap.launching)) {
                    ctx.fillStyle = CONFIG.TRAP_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Add detail stripes (same as falling blocks)
                    ctx.fillStyle = '#cc5555';
                    ctx.fillRect(trap.x + 5, trap.y + 5, trap.width - 10, 3);
                    ctx.fillRect(trap.x + 5, trap.y + trap.height - 8, trap.width - 10, 3);
                }

                // Draw ceiling spikes (pointing down)
                if (trap.type === 'ceilingSpikes' && trap.visible) {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.width / 20);
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + trap.height);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + trap.height - 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw popup spikes (same as floor spikes but only when visible)
                if (trap.type === 'popupSpikes' && trap.visible) {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.width / 20);
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y + trap.height);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y + trap.height);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + trap.height - 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + trap.height - 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw timed box - just a plain simple box, no hints!
                if (trap.type === 'timedBox' && !trap.gone) {
                    ctx.fillStyle = '#8B4513';  // Brown color
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                }

                // Draw fake door (looks like a door but it's a trap!)
                if (trap.type === 'fakeDoor') {
                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                    // Door handle
                    ctx.fillStyle = '#3a9a5a';
                    ctx.beginPath();
                    ctx.arc(trap.x + 32, trap.y + 35, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw chase wall (moving spike wall)
                if (trap.type === 'chaseWall' && trap.active) {
                    // Wall body
                    ctx.fillStyle = '#cc3333';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Spikes on the right side (pointing toward player)
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.height / 30);
                    const spikeHeight = trap.height / spikeCount;
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + trap.width, trap.y + i * spikeHeight);
                        ctx.lineTo(trap.x + trap.width + 20, trap.y + i * spikeHeight + spikeHeight / 2);
                        ctx.lineTo(trap.x + trap.width, trap.y + (i + 1) * spikeHeight);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Door smash debris effect
                    if (trap.doorSmashed && trap.doorSmashAnim > 0) {
                        ctx.fillStyle = `rgba(80, 200, 120, ${trap.doorSmashAnim})`;
                        // Exploding door fragments
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2;
                            const dist = (1 - trap.doorSmashAnim) * 100;
                            const fragX = trap.smashX + 20 + Math.cos(angle) * dist;
                            const fragY = trap.smashY + 30 + Math.sin(angle) * dist;
                            const size = 8 + Math.random() * 8;
                            ctx.fillRect(fragX, fragY, size, size);
                        }
                    }
                }

                // Draw ceiling popup spikes (appear when triggered)
                if (trap.type === 'ceilingPopupSpikes' && trap.visible) {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.width / 20);
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + trap.height);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Spike shine
                    ctx.fillStyle = '#ff8888';
                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth + spikeWidth * 0.3, trap.y + 2);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + trap.height - 3);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth * 0.5, trap.y + 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }

                // Draw fake arrows (Level 25 - lying arrows)
                if (trap.type === 'fakeArrow') {
                    ctx.save();
                    ctx.fillStyle = '#ffcc00';  // Yellow/gold arrows (looks helpful!)
                    ctx.strokeStyle = '#996600';
                    ctx.lineWidth = 2;

                    const arrowX = trap.x;
                    const arrowY = trap.y;
                    const arrowSize = 30;

                    ctx.translate(arrowX + arrowSize/2, arrowY + arrowSize/2);

                    // Rotate based on direction
                    if (trap.direction === 'right') ctx.rotate(0);
                    else if (trap.direction === 'down') ctx.rotate(Math.PI / 2);
                    else if (trap.direction === 'left') ctx.rotate(Math.PI);
                    else if (trap.direction === 'up') ctx.rotate(-Math.PI / 2);

                    // Draw arrow shape pointing right (will be rotated)
                    ctx.beginPath();
                    ctx.moveTo(arrowSize/2, 0);  // Tip
                    ctx.lineTo(arrowSize/4, -arrowSize/3);  // Top back
                    ctx.lineTo(arrowSize/4, -arrowSize/6);  // Top notch
                    ctx.lineTo(-arrowSize/2, -arrowSize/6);  // Back top
                    ctx.lineTo(-arrowSize/2, arrowSize/6);   // Back bottom
                    ctx.lineTo(arrowSize/4, arrowSize/6);   // Bottom notch
                    ctx.lineTo(arrowSize/4, arrowSize/3);   // Bottom back
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Add friendly shimmer effect
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, -5, 3, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw shadow button (must be pressed by shadow)
                if (trap.type === 'shadowButton') {
                    ctx.fillStyle = trap.pressed ? '#00ff00' : '#666666';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button border
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);

                    // Label
                    ctx.fillStyle = trap.pressed ? '#005500' : '#999999';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('SHADOW', trap.x + trap.width/2, trap.y + trap.height/2 + 4);
                }

                // Draw platformer button (player presses to reveal door)
                if (trap.type === 'yourFollowerButton') {
                    ctx.fillStyle = trap.pressed ? '#00ff00' : '#cc4444';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Button border
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(trap.x, trap.y, trap.width, trap.height);

                    // 3D effect
                    if (!trap.pressed) {
                        ctx.fillStyle = '#ff6666';
                        ctx.fillRect(trap.x + 3, trap.y + 2, trap.width - 6, trap.height/2 - 2);
                    }
                }

                // Draw the enemy (Role Reversal level)
                if (trap.type === 'yourEnemy' && trap.alive) {
                    ctx.save();
                    // Body - dark menacing color
                    ctx.fillStyle = '#442266';
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);

                    // Armored shoulders
                    ctx.fillStyle = '#553388';
                    ctx.fillRect(trap.x - 8, trap.y + 5, 15, 20);
                    ctx.fillRect(trap.x + trap.width - 7, trap.y + 5, 15, 20);

                    // Menacing helmet
                    ctx.fillStyle = '#331155';
                    ctx.beginPath();
                    ctx.moveTo(trap.x + trap.width/2, trap.y - 15);
                    ctx.lineTo(trap.x - 5, trap.y + 15);
                    ctx.lineTo(trap.x + trap.width + 5, trap.y + 15);
                    ctx.closePath();
                    ctx.fill();

                    // Glowing eyes
                    ctx.fillStyle = '#ff0066';
                    ctx.beginPath();
                    ctx.arc(trap.x + 15, trap.y + 20, 5, 0, Math.PI * 2);
                    ctx.arc(trap.x + trap.width - 15, trap.y + 20, 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Eye glow effect
                    ctx.fillStyle = 'rgba(255, 0, 102, 0.3)';
                    ctx.beginPath();
                    ctx.arc(trap.x + 15, trap.y + 20, 10, 0, Math.PI * 2);
                    ctx.arc(trap.x + trap.width - 15, trap.y + 20, 10, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                }

                // Draw controllable spike (Role Reversal level) - looks like normal spike
                if (trap.type === 'yourSpike') {
                    // Red spike
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.moveTo(trap.x + trap.width/2, trap.y);  // Tip
                    ctx.lineTo(trap.x, trap.y + trap.height);   // Bottom left
                    ctx.lineTo(trap.x + trap.width, trap.y + trap.height);  // Bottom right
                    ctx.closePath();
                    ctx.fill();

                    // Shine
                    ctx.fillStyle = '#ff8888';
                    ctx.beginPath();
                    ctx.moveTo(trap.x + trap.width/2, trap.y + 5);
                    ctx.lineTo(trap.x + trap.width/2 - 5, trap.y + trap.height - 2);
                    ctx.lineTo(trap.x + trap.width/2, trap.y + trap.height - 2);
                    ctx.closePath();
                    ctx.fill();
                }

                // Draw portal door (Portal level)
                if (trap.type === 'portalDoor') {
                    ctx.fillStyle = CONFIG.DOOR_COLOR;
                    ctx.fillRect(trap.x, trap.y, trap.width, trap.height);
                    // Door handle
                    ctx.fillStyle = '#3a9a5a';
                    ctx.beginPath();
                    ctx.arc(trap.x + 8, trap.y + 35, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw hidden pit (Level 24 - looks like floor until stepped on)
                if (trap.type === 'hiddenPit') {
                    if (trap.revealed && trap.falling) {
                        // Show the falling platform section
                        ctx.fillStyle = CONFIG.GROUND_COLOR;
                        ctx.globalAlpha = Math.max(0, 1 - (trap.fallY - trap.y) / 200);
                        ctx.fillRect(trap.x, trap.fallY, trap.width, trap.height);
                        ctx.globalAlpha = 1;

                        // Crumbling particles
                        ctx.fillStyle = '#666666';
                        for (let i = 0; i < 5; i++) {
                            const px = trap.x + Math.random() * trap.width;
                            const py = trap.fallY + Math.random() * 20;
                            ctx.fillRect(px, py, 4, 4);
                        }
                    }
                    // When not revealed, it just looks like normal floor (platform handles it)
                }

                // Draw ceiling spikes (static)
                if (trap.type === 'ceilingSpikes' && trap.extended) {
                    ctx.fillStyle = '#ff4444';
                    const spikeCount = Math.floor(trap.width / 20);
                    const spikeWidth = trap.width / spikeCount;

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(trap.x + i * spikeWidth, trap.y);
                        ctx.lineTo(trap.x + i * spikeWidth + spikeWidth / 2, trap.y + trap.height);
                        ctx.lineTo(trap.x + (i + 1) * spikeWidth, trap.y);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            // Draw shadow (copycat level) - before player so player appears on top
            if (shadow.active && shadow.history.length > shadow.delay / 16) {
                ctx.save();
                ctx.globalAlpha = 0.5;

                // Shadow body (dark silhouette of player)
                ctx.fillStyle = '#333333';
                ctx.fillRect(shadow.x, shadow.y, player.width, player.height);

                // Shadow eyes (menacing red)
                const shadowEyeY = shadow.y + 12;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(shadow.x + 8, shadowEyeY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(shadow.x + 18, shadowEyeY, 4, 0, Math.PI * 2);
                ctx.fill();

                // Glowing outline
                ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(shadow.x - 1, shadow.y - 1, player.width + 2, player.height + 2);

                ctx.restore();
            }

            // Draw fake timer (Level 24)
            if (fakeTimer.active) {
                const seconds = Math.ceil(fakeTimer.timeLeft / 1000);

                if (!fakeTimer.revealed) {
                    // Scary red countdown
                    ctx.save();
                    ctx.fillStyle = seconds <= 2 ? '#ff0000' : '#ff4444';
                    ctx.font = 'bold 80px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Pulsing effect when time is low
                    if (seconds <= 2) {
                        const pulse = 1 + Math.sin(Date.now() / 100) * 0.1;
                        ctx.translate(canvas.width / 2, 80);
                        ctx.scale(pulse, pulse);
                        ctx.translate(-canvas.width / 2, -80);
                    }

                    ctx.fillText(seconds.toString(), canvas.width / 2, 80);

                    // "HURRY!" text
                    ctx.font = 'bold 24px Arial';
                    ctx.fillText('HURRY!', canvas.width / 2, 130);
                    ctx.restore();
                } else {
                    // Revealed as fake - show "FAKE!" with crossed out timer
                    ctx.save();
                    ctx.fillStyle = '#00ff00';
                    ctx.font = 'bold 60px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('FAKE!', canvas.width / 2, 80);

                    ctx.font = '24px Arial';
                    ctx.fillStyle = '#88ff88';
                    ctx.fillText('The timer was a lie! Door revealed.', canvas.width / 2, 120);
                    ctx.restore();
                }
            }

            // Portal teleport animation
            if (portalState.teleporting) {
                ctx.save();
                const t = portalState.teleportAnim;

                if (t < 0.5) {
                    // First half: player shrinks into ground door
                    const shrink = 1 - (t * 2);
                    const doorCenterX = door.x + door.width / 2;
                    const doorCenterY = door.y + door.height / 2;

                    // Move toward door center as shrinking
                    const px = player.x + (doorCenterX - player.x - player.width/2) * (t * 2);
                    const py = player.y + (doorCenterY - player.y - player.height/2) * (t * 2);

                    ctx.translate(px + player.width/2, py + player.height/2);
                    ctx.scale(shrink, shrink);
                    ctx.translate(-player.width/2, -player.height/2);

                    ctx.fillStyle = CONFIG.PLAYER_COLOR;
                    ctx.fillRect(0, 0, player.width, player.height);
                } else {
                    // Second half: player grows out of portal door
                    const portalDoor = traps.find(t => t.type === 'portalDoor');
                    if (portalDoor) {
                        const grow = (t - 0.5) * 2;
                        const doorCenterX = portalDoor.x + portalDoor.width + player.width/2;
                        const doorCenterY = portalDoor.y + portalDoor.height - player.height/2;

                        ctx.translate(doorCenterX, doorCenterY);
                        ctx.scale(grow, grow);
                        ctx.translate(-player.width/2, -player.height/2);

                        ctx.fillStyle = CONFIG.PLAYER_COLOR;
                        ctx.fillRect(0, 0, player.width, player.height);
                    }
                }
                ctx.restore();
                // Skip normal player drawing during teleport
            } else {
            // Draw player with squash/stretch
            ctx.save();

            // Move to player center for scaling
            const centerX = player.x + player.width / 2;
            const centerY = player.y + player.height / 2;
            ctx.translate(centerX, centerY);
            ctx.scale(player.scaleX, player.scaleY);
            ctx.translate(-centerX, -centerY);

            // Skip drawing if fully invisible
            if (player.invisible) {
                ctx.restore();
                // But still show a subtle hint sparkle effect occasionally
                if (Math.random() < 0.02) {
                    ctx.fillStyle = 'rgba(100, 100, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(player.x + player.width/2 + (Math.random()-0.5)*20,
                            player.y + player.height/2 + (Math.random()-0.5)*20,
                            2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else {
                // Handle partial visibility (fading in/out based on light)
                if (player.invisibleAnim > 0) {
                    ctx.globalAlpha = 1 - player.invisibleAnim;
                }

                // Player body
                ctx.fillStyle = CONFIG.PLAYER_COLOR;
                ctx.fillRect(player.x, player.y, player.width, player.height);

            // Eyes - look in movement direction (or X's when dead)
            const eyeOffsetX = player.facingRight ? 3 : -3;
            const eyeY = player.y + 12;
            const leftEyeX = player.x + 8;
            const rightEyeX = player.x + 18;

            if (player.dead) {
                // X eyes when dead
                ctx.strokeStyle = CONFIG.EYE_COLOR;
                ctx.lineWidth = 2;

                // Left X
                ctx.beginPath();
                ctx.moveTo(leftEyeX - 4, eyeY - 4);
                ctx.lineTo(leftEyeX + 4, eyeY + 4);
                ctx.moveTo(leftEyeX + 4, eyeY - 4);
                ctx.lineTo(leftEyeX - 4, eyeY + 4);
                ctx.stroke();

                // Right X
                ctx.beginPath();
                ctx.moveTo(rightEyeX - 4, eyeY - 4);
                ctx.lineTo(rightEyeX + 4, eyeY + 4);
                ctx.moveTo(rightEyeX + 4, eyeY - 4);
                ctx.lineTo(rightEyeX - 4, eyeY + 4);
                ctx.stroke();
            } else {
                // Normal eyes
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.ellipse(leftEyeX, eyeY, 5, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(rightEyeX, eyeY, 5, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils - follow movement direction
                ctx.fillStyle = CONFIG.EYE_COLOR;
                ctx.beginPath();
                ctx.arc(leftEyeX + eyeOffsetX, eyeY, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(rightEyeX + eyeOffsetX, eyeY, 2.5, 0, Math.PI * 2);
                ctx.fill();
            }

                ctx.globalAlpha = 1;  // Reset alpha after drawing
                ctx.restore();
            }
            }  // End of else block for teleport animation

            // Shrinking sparkle effect (only show if not invisible)
            if (player.shrinking && !player.invisible) {
                ctx.fillStyle = '#ffee55';
                for (let i = 0; i < 8; i++) {
                    const angle = (Date.now() / 100 + i * Math.PI / 4) % (Math.PI * 2);
                    const dist = 20 + Math.sin(Date.now() / 50 + i) * 10;
                    const sparkleX = player.x + player.width / 2 + Math.cos(angle) * dist;
                    const sparkleY = player.y + player.height / 2 + Math.sin(angle) * dist;
                    const size = 2 + Math.random() * 3;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Inner glow
                ctx.fillStyle = 'rgba(255, 238, 85, 0.3)';
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, 25, 0, Math.PI * 2);
                ctx.fill();
            }

            // Level complete flash effect
            if (levelComplete) {
                ctx.fillStyle = 'rgba(80, 200, 120, 0.3)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Death flash effect
            if (player.dead) {
                // Pulsing red overlay
                const pulse = Math.sin(Date.now() / 100) * 0.1 + 0.2;
                ctx.fillStyle = `rgba(255, 50, 50, ${pulse})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            // Darkness overlay for "Lights Out" levels
            const levelData = LEVELS[currentLevel];
            if (levelData.isDark) {
                const radius = levelData.visibilityRadius || 80;
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;

                // Create darkness with radial gradient (visible circle around player)
                ctx.save();
                ctx.globalCompositeOperation = 'source-over';

                // Draw dark overlay with circular cutout
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.rect(0, 0, canvas.width, canvas.height);
                ctx.arc(playerCenterX, playerCenterY, radius, 0, Math.PI * 2, true);
                ctx.fill();

                // Add soft edge to visibility circle
                const gradient = ctx.createRadialGradient(
                    playerCenterX, playerCenterY, radius * 0.7,
                    playerCenterX, playerCenterY, radius
                );
                gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                gradient.addColorStop(1, 'rgba(0, 0, 0, 0.8)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(playerCenterX, playerCenterY, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            }
        }

        // ===========================================
        // GAME LOOP
        // ===========================================

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ===========================================
        // START GAME
        // ===========================================

        // Start at level 1
        currentLevel = 0;
        loadLevel(currentLevel);
        gameLoop();
    </script>
</body>
</html>
